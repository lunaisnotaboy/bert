{
  "$schema": "http://json-schema.org/draft-07/schema",
  "title": "RuboCop configuration schema",
  "description": "Schema for RuboCop configuration files (e.g. .rubocop.yml), intended for helping IDEs provide autocompletion and validation.",
  "type": "object",
  "additionalProperties": false,
  "definitions": {
    "inherit_mode": {
      "type": "object",
      "minProperties": 1,
      "propertyNames": {
        "enum": [
          "merge",
          "override"
        ]
      },
      "additionalProperties": {
        "type": "array",
        "minItems": 1,
        "items": {
          "type": "string"
        }
      }
    },
    "listOfFiles": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "severity": {
      "type": "string",
      "enum": [
        "info",
        "refactor",
        "convention",
        "warning",
        "error",
        "fatal"
      ]
    },
    "stringOrStrings": {
      "oneOf": [
        {
          "type": "string"
        },
        {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      ]
    },
    "attributeName": {
      "type": "string",
      "pattern": "^[A-Z][A-Za-z]*$"
    }
  },
  "properties": {
    "inherit_from": {
      "type": "string"
    },
    "inherit_gem": {
      "type": "object",
      "additionalProperties": {
        "$ref": "#/definitions/stringOrStrings"
      }
    },
    "require": {
      "$ref": "#/definitions/stringOrStrings"
    },
    "inherit_mode": {
      "$ref": "#/definitions/inherit_mode"
    },
    "AllCops": {
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: node_modules/**/*, tmp/**/*, vendor/**/*, .git/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.rb, **/*.arb, **/*.axlsx, **/*.builder, **/*.fcgi, **/*.gemfile, **/*.gemspec, **/*.god, **/*.jb, **/*.jbuilder, **/*.mspec, **/*.opal, **/*.pluginspec, **/*.podspec, **/*.rabl, **/*.rake, **/*.rbuild, **/*.rbw, **/*.rbx, **/*.ru, **/*.ruby, **/*.schema, **/*.spec, **/*.thor, **/*.watchr, **/.irbrc, **/.pryrc, **/.simplecov, **/buildfile, **/Appraisals, **/Berksfile, **/Brewfile, **/Buildfile, **/Capfile, **/Cheffile, **/Dangerfile, **/Deliverfile, **/Fastfile, **/*Fastfile, **/Gemfile, **/Guardfile, **/Jarfile, **/Mavenfile, **/Podfile, **/Puppetfile, **/Rakefile, **/rakefile, **/Schemafile, **/Snapfile, **/Steepfile, **/Thorfile, **/Vagabondfile, **/Vagrantfile"
        },
        "NewCops": {
          "enum": [
            "enable",
            "disable"
          ],
          "type": "string",
          "description": "Default: pending"
        },
        "EnabledByDefault": {
          "type": "boolean",
          "description": "Default: false"
        },
        "DisabledByDefault": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SuggestExtensions": {
          "type": "boolean",
          "description": "Default: {\"rubocop-rails\"=>[\"rails\"], \"rubocop-rspec\"=>[\"rspec\", \"rspec-rails\"], \"rubocop-minitest\"=>[\"minitest\"], \"rubocop-sequel\"=>[\"sequel\"], \"rubocop-rake\"=>[\"rake\"], \"rubocop-graphql\"=>[\"graphql\"], \"rubocop-capybara\"=>[\"capybara\"], \"rubocop-factory_bot\"=>[\"factory_bot\", \"factory_bot_rails\"]}"
        },
        "TargetRubyVersion": {
          "type": "number"
        },
        "StyleGuideBaseURL": {
          "type": "string",
          "description": "Default: https://rubystyle.guide"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Enabled": {
          "type": "boolean"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "RubyInterpreters": {
          "type": "array",
          "description": "Default: ruby, macruby, rake, jruby, rbx"
        },
        "DefaultFormatter": {
          "type": "string",
          "description": "Default: progress"
        },
        "DisplayCopNames": {
          "type": "boolean",
          "description": "Default: true"
        },
        "DisplayStyleGuide": {
          "type": "boolean",
          "description": "Default: false"
        },
        "DocumentationBaseURL": {
          "type": "string",
          "description": "Default: https://docs.rubocop.org/rubocop"
        },
        "ExtraDetails": {
          "type": "boolean",
          "description": "Default: false"
        },
        "StyleGuideCopsOnly": {
          "type": "boolean",
          "description": "Default: false"
        },
        "UseCache": {
          "type": "boolean",
          "description": "Default: true"
        },
        "MaxFilesInCache": {
          "type": "integer",
          "description": "Default: 20000"
        },
        "CacheRootDirectory": {
        },
        "AllowSymlinksInCacheRootDirectory": {
          "type": "boolean",
          "description": "Default: false"
        },
        "ActiveSupportExtensionsEnabled": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      }
    },
    "Bundler": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Bundler' department"
    },
    "Bundler/DuplicatedGem": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "A Gem's requirements should be listed only once in a Gemfile."
    },
    "Bundler/DuplicatedGroup": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "A Gem group, or a set of groups, should be listed only once in a Gemfile.\n\nFor example, if the values of `source`, `git`, `platforms`, or `path` surrounding `group` are different, no offense will be registered:\n\nplatforms :ruby do   group :default do     gem 'openssl'   end end  platforms :jruby do   group :default do     gem 'jruby-openssl'   end end"
    },
    "Bundler/GemComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoredGems": {
          "type": "array",
          "description": "Default: []"
        },
        "OnlyFor": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Each gem in the Gemfile should have a comment explaining its purpose in the project, or the reason for its version or source.\n\nThe optional \"OnlyFor\" configuration array can be used to only register offenses when the gems use certain options or have version specifiers.\n\nWhen \"version_specifiers\" is included, a comment will be enforced if the gem has any version specifier.\n\nWhen \"restrictive_version_specifiers\" is included, a comment will be enforced if the gem has a version specifier that holds back the version of the gem.\n\nFor any other value in the array, a comment will be enforced for a gem if an option by the same name is present. A useful use case is to enforce a comment when using options that change the source of a gem:\n\n - bitbucket\n\n - gist\n\n - git\n\n - github\n\n - source\n\nFor a full list of options supported by bundler, see https://bundler.io/man/gemfile.5.html ."
    },
    "Bundler/GemFilename": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/Gemfile, **/gems.rb, **/Gemfile.lock, **/gems.locked"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "Gemfile",
            "gems.rb"
          ],
          "description": "Default: Gemfile"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: Gemfile, gems.rb"
        }
      },
      "description": "Verifies that a project contains Gemfile or gems.rb file and correct associated lock file based on the configuration."
    },
    "Bundler/GemVersion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "required",
            "forbidden"
          ],
          "description": "Default: required"
        },
        "AllowedGems": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: required, forbidden"
        }
      },
      "description": "Enforce that Gem version specifications or a commit reference (branch, ref, or tag) are either required or forbidden."
    },
    "Bundler/InsecureProtocolSource": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowHttpProtocol": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Passing symbol arguments to `source` (e.g. `source :rubygems`) is deprecated because they default to using HTTP requests. Instead, specify `'https://rubygems.org'` if possible, or `'http://rubygems.org'` if not.\n\nWhen autocorrecting, this cop will replace symbol arguments with `'https://rubygems.org'`.\n\nThis cop will not replace existing sources that use `http://`. This may be necessary where HTTPS is not available. For example, where using an internal gem server via an intranet, or where HTTPS is prohibited. However, you should strongly prefer `https://` where possible, as it is more secure.\n\nIf you don't allow `http://`, please set `false` to `AllowHttpProtocol`. This option is `true` by default for safe autocorrection."
    },
    "Bundler/OrderedGems": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "TreatCommentsAsGroupSeparators": {
          "type": "boolean",
          "description": "Default: true"
        },
        "ConsiderPunctuation": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Gems should be alphabetically sorted within groups."
    },
    "Gemspec": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Gemspec' department"
    },
    "Gemspec/DependencyVersion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "required",
            "forbidden"
          ],
          "description": "Default: required"
        },
        "AllowedGems": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: required, forbidden"
        }
      },
      "description": "Enforce that gem dependency version specifications or a commit reference (branch, ref, or tag) are either required or forbidden."
    },
    "Gemspec/DeprecatedAttributeAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks that deprecated attributes are not set in a gemspec file. Removing deprecated attributes allows the user to receive smaller packed gems."
    },
    "Gemspec/DevelopmentDependencies": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec, **/Gemfile, **/gems.rb"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "Gemfile",
            "gems.rb",
            "gemspec"
          ],
          "description": "Default: Gemfile"
        },
        "AllowedGems": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: Gemfile, gems.rb, gemspec"
        }
      },
      "description": "Enforce that development dependencies for a gem are specified in `Gemfile`, rather than in the `gemspec` using `add_development_dependency`. Alternatively, using `EnforcedStyle: gemspec`, enforce that all dependencies are specified in `gemspec`, rather than in `Gemfile`."
    },
    "Gemspec/DuplicatedAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "An attribute assignment method calls should be listed only once in a gemspec.\n\nAssigning to an attribute with the same name using `spec.foo =` will be an unintended usage. On the other hand, duplication of methods such as `spec.requirements`, `spec.add_runtime_dependency`, and others are permitted because it is the intended use of appending values."
    },
    "Gemspec/OrderedDependencies": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "TreatCommentsAsGroupSeparators": {
          "type": "boolean",
          "description": "Default: true"
        },
        "ConsiderPunctuation": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Dependencies in the gemspec should be alphabetically sorted."
    },
    "Gemspec/RequireMFA": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://guides.rubygems.org/mfa-requirement-opt-in/"
        }
      },
      "description": "Requires a gemspec to have `rubygems_mfa_required` metadata set.\n\nThis setting tells RubyGems that MFA (Multi-Factor Authentication) is required for accounts to be able perform privileged operations, such as (see RubyGems' documentation for the full list of privileged operations):\n\n - gem push\n\n - gem yank\n\n - gem owner --add/remove\n\n - adding or removing owners using gem ownership page\n\nThis helps make your gem more secure, as users can be more confident that gem updates were pushed by maintainers."
    },
    "Gemspec/RequiredRubyVersion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that `required_ruby_version` in a gemspec file is set to a valid value (non-blank) and matches `TargetRubyVersion` as set in RuboCop's configuration for the gem.\n\nThis ensures that RuboCop is using the same Ruby version as the gem."
    },
    "Gemspec/RubyVersionGlobalsUsage": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that `RUBY_VERSION` constant is not used in gemspec. Using `RUBY_VERSION` is dangerous because value of the constant is determined by `rake release`. It's possible to have dependency based on ruby version used to execute `rake release` and not user's ruby version."
    },
    "Layout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Layout' department"
    },
    "Layout/AccessModifierIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "outdent",
            "indent"
          ],
          "description": "Default: indent"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: outdent, indent"
        }
      },
      "description": "Bare access modifiers (those not applying to specific methods) should be indented as deep as method definitions, or as deep as the class/module keyword, depending on configuration."
    },
    "Layout/ArgumentAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "with_first_argument",
            "with_fixed_indentation"
          ],
          "description": "Default: with_first_argument"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: with_first_argument, with_fixed_indentation"
        }
      },
      "description": "Here we check if the arguments on a multi-line method definition are aligned."
    },
    "Layout/ArrayAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "with_first_element",
            "with_fixed_indentation"
          ],
          "description": "Default: with_first_element"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: with_first_element, with_fixed_indentation"
        }
      },
      "description": "Here we check if the elements of a multi-line array literal are aligned."
    },
    "Layout/AssignmentIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        }
      },
      "description": "Checks the indentation of the first line of the right-hand-side of a multi-line assignment.\n\nThe indentation of the remaining lines can be corrected with other cops such as `IndentationConsistency` and `EndAlignment`."
    },
    "Layout/BeginEndAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyleAlignWith": {
          "enum": [
            "start_of_line",
            "begin"
          ],
          "description": "Default: start_of_line"
        },
        "SupportedStylesAlignWith": {
          "type": "array",
          "description": "Default: start_of_line, begin"
        }
      },
      "description": "Checks whether the end keyword of `begin` is aligned properly.\n\nTwo modes are supported through the `EnforcedStyleAlignWith` configuration parameter. If it's set to `start_of_line` (which is the default), the `end` shall be aligned with the start of the line where the `begin` keyword is. If it's set to `begin`, the `end` shall be aligned with the `begin` keyword.\n\n`Layout/EndAlignment` cop aligns with keywords (e.g. `if`, `while`, `case`) by default. On the other hand, `||= begin` that this cop targets tends to align with the start of the line, it defaults to `EnforcedStyleAlignWith: start_of_line`. These style can be configured by each cop."
    },
    "Layout/BlockAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyleAlignWith": {
          "enum": [
            "either",
            "start_of_block",
            "start_of_line"
          ],
          "description": "Default: either"
        },
        "SupportedStylesAlignWith": {
          "type": "array",
          "description": "Default: either, start_of_block, start_of_line"
        }
      },
      "description": "Checks whether the end keywords are aligned properly for do end blocks.\n\nThree modes are supported through the `EnforcedStyleAlignWith` configuration parameter:\n\n`start_of_block` : the `end` shall be aligned with the start of the line where the `do` appeared.\n\n`start_of_line` : the `end` shall be aligned with the start of the line where the expression started.\n\n`either` (which is the default) : the `end` is allowed to be in either location. The autofixer will default to `start_of_line`."
    },
    "Layout/BlockEndNewline": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks whether the end statement of a do..end block is on its own line."
    },
    "Layout/CaseIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "case",
            "end"
          ],
          "description": "Default: case"
        },
        "IndentOneStep": {
          "type": "boolean",
          "description": "Default: false"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: case, end"
        }
      },
      "description": "Checks how the `when` and ``in``s of a `case` expression are indented in relation to its `case` or `end` keyword.\n\nIt will register a separate offense for each misaligned `when` and `in`."
    },
    "Layout/ClassStructure": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Categories": {
          "description": "Default: {\"module_inclusion\"â‡’[\"include\", \"prepend\", \"extend\"]}"
        },
        "ExpectedOrder": {
          "type": "array",
          "description": "Default: module_inclusion, constants, public_class_methods, initializer, public_methods, protected_methods, private_methods"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks if the code style follows the ExpectedOrder configuration:\n\n`Categories` allows us to map macro names into a category.\n\nConsider an example of code style that covers the following order:\n\n - Module inclusion (include, prepend, extend)\n\n - Constants\n\n - Associations (has_one, has_many)\n\n - Public attribute macros (attr_accessor, attr_writer, attr_reader)\n\n - Other macros (validates, validate)\n\n - Public class methods\n\n - Initializer\n\n - Public instance methods\n\n - Protected attribute macros (attr_accessor, attr_writer, attr_reader)\n\n - Protected instance methods\n\n - Private attribute macros (attr_accessor, attr_writer, attr_reader)\n\n - Private instance methods\n\nYou can configure the following order:\n\n Layout/ClassStructure:    ExpectedOrder:      - module_inclusion      - constants      - association      - public_attribute_macros      - public_delegate      - macros      - public_class_methods      - initializer      - public_methods      - protected_attribute_macros      - protected_methods      - private_attribute_macros      - private_delegate      - private_methods\n\nInstead of putting all literals in the expected order, is also possible to group categories of macros. Visibility levels are handled automatically.\n\n Layout/ClassStructure:    Categories:      association:        - has_many        - has_one      attribute_macros:        - attr_accessor        - attr_reader        - attr_writer      macros:        - validates        - validate      module_inclusion:        - include        - prepend        - extend"
    },
    "Layout/ClosingHeredocIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks the indentation of here document closings."
    },
    "Layout/ClosingParenthesisIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks the indentation of hanging closing parentheses in method calls, method definitions, and grouped expressions. A hanging closing parenthesis means `)` preceded by a line break."
    },
    "Layout/CommentIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowForAlignment": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks the indentation of comments."
    },
    "Layout/ConditionPosition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for conditions that are not on the same line as if/while/until."
    },
    "Layout/DefEndAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyleAlignWith": {
          "enum": [
            "start_of_line",
            "def"
          ],
          "description": "Default: start_of_line"
        },
        "SupportedStylesAlignWith": {
          "type": "array",
          "description": "Default: start_of_line, def"
        }
      },
      "description": "Checks whether the end keywords of method definitions are aligned properly.\n\nTwo modes are supported through the EnforcedStyleAlignWith configuration parameter. If it's set to `start_of_line` (which is the default), the `end` shall be aligned with the start of the line where the `def` keyword is. If it's set to `def`, the `end` shall be aligned with the `def` keyword."
    },
    "Layout/DotPosition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "leading",
            "trailing"
          ],
          "description": "Default: leading"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: leading, trailing"
        }
      },
      "description": "Checks the . position in multi-line method calls."
    },
    "Layout/ElseAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks the alignment of else keywords. Normally they should be aligned with an if/unless/while/until/begin/def/rescue keyword, but there are special cases when they should follow the same rules as the alignment of end."
    },
    "Layout/EmptyComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowBorderComment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowMarginComment": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks empty comment."
    },
    "Layout/EmptyLineAfterGuardClause": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Enforces empty line after guard clause.\n\nThis cop allows `# :nocov:` directive after guard clause because SimpleCov excludes code from the coverage report by wrapping it in `# :nocov:`:\n\ndef foo   # :nocov:   return if condition   # :nocov:   bar end\n\nRefer to SimpleCov's documentation for more details: https://github.com/simplecov-ruby/simplecov#ignoringskipping-code"
    },
    "Layout/EmptyLineAfterMagicComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for a newline after the final magic comment."
    },
    "Layout/EmptyLineAfterMultilineCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://github.com/airbnb/ruby#multiline-if-newline"
        }
      },
      "description": "Enforces empty line after multiline condition."
    },
    "Layout/EmptyLineBetweenDefs": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EmptyLineBetweenMethodDefs": {
          "type": "boolean",
          "description": "Default: true"
        },
        "EmptyLineBetweenClassDefs": {
          "type": "boolean",
          "description": "Default: true"
        },
        "EmptyLineBetweenModuleDefs": {
          "type": "boolean",
          "description": "Default: true"
        },
        "DefLikeMacros": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowAdjacentOneLineDefs": {
          "type": "boolean",
          "description": "Default: true"
        },
        "NumberOfEmptyLines": {
          "type": "integer",
          "description": "Default: 1"
        }
      },
      "description": "Checks whether class/module/method definitions are separated by one or more empty lines.\n\n`NumberOfEmptyLines` can be an integer (default is 1) or an array (e.g. [1, 2]) to specify a minimum and maximum number of empty lines permitted.\n\n`AllowAdjacentOneLineDefs` configures whether adjacent one-line definitions are considered an offense."
    },
    "Layout/EmptyLines": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for two or more consecutive blank lines."
    },
    "Layout/EmptyLinesAroundAccessModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "around",
            "only_before"
          ],
          "description": "Default: around"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: around, only_before"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#follow-the-coding-conventions"
        }
      },
      "description": "Access modifiers should be surrounded by blank lines."
    },
    "Layout/EmptyLinesAroundArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks if empty lines exist around the arguments of a method invocation."
    },
    "Layout/EmptyLinesAroundAttributeAccessor": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowAliasSyntax": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: alias_method, public, protected, private"
        }
      },
      "description": "Checks for a newline after an attribute accessor or a group of them. `alias` syntax and `alias_method`, `public`, `protected`, and `private` methods are allowed by default. These are customizable with `AllowAliasSyntax` and `AllowedMethods` options."
    },
    "Layout/EmptyLinesAroundBeginBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks if empty lines exist around the bodies of begin-end blocks."
    },
    "Layout/EmptyLinesAroundBlockBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "empty_lines",
            "no_empty_lines"
          ],
          "description": "Default: no_empty_lines"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: empty_lines, no_empty_lines"
        }
      },
      "description": "Checks if empty lines around the bodies of blocks match the configuration."
    },
    "Layout/EmptyLinesAroundClassBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "empty_lines",
            "empty_lines_except_namespace",
            "empty_lines_special",
            "no_empty_lines",
            "beginning_only",
            "ending_only"
          ],
          "description": "Default: no_empty_lines"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: empty_lines, empty_lines_except_namespace, empty_lines_special, no_empty_lines, beginning_only, ending_only"
        }
      },
      "description": "Checks if empty lines around the bodies of classes match the configuration."
    },
    "Layout/EmptyLinesAroundExceptionHandlingKeywords": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks if empty lines exist around the bodies of `begin` sections. This cop doesn't check empty lines at `begin` body beginning/end and around method definition body. `Style/EmptyLinesAroundBeginBody` or `Style/EmptyLinesAroundMethodBody` can be used for this purpose."
    },
    "Layout/EmptyLinesAroundMethodBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks if empty lines exist around the bodies of methods."
    },
    "Layout/EmptyLinesAroundModuleBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "empty_lines",
            "empty_lines_except_namespace",
            "empty_lines_special",
            "no_empty_lines"
          ],
          "description": "Default: no_empty_lines"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: empty_lines, empty_lines_except_namespace, empty_lines_special, no_empty_lines"
        }
      },
      "description": "Checks if empty lines around the bodies of modules match the configuration."
    },
    "Layout/EndAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity",
          "description": "Default: warning"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyleAlignWith": {
          "enum": [
            "keyword",
            "variable",
            "start_of_line"
          ],
          "description": "Default: keyword"
        },
        "SupportedStylesAlignWith": {
          "type": "array",
          "description": "Default: keyword, variable, start_of_line"
        }
      },
      "description": "Checks whether the end keywords are aligned properly.\n\nThree modes are supported through the `EnforcedStyleAlignWith` configuration parameter:\n\nIf it's set to `keyword` (which is the default), the `end` shall be aligned with the start of the keyword (if, class, etc.).\n\nIf it's set to `variable` the `end` shall be aligned with the left-hand-side of the variable assignment, if there is one.\n\nIf it's set to `start_of_line`, the `end` shall be aligned with the start of the line where the matching keyword appears.\n\nThis `Layout/EndAlignment` cop aligns with keywords (e.g. `if`, `while`, `case`) by default. On the other hand, `Layout/BeginEndAlignment` cop aligns with `EnforcedStyleAlignWith: start_of_line` by default due to `||= begin` tends to align with the start of the line. These style can be configured by each cop."
    },
    "Layout/EndOfLine": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "native",
            "lf",
            "crlf"
          ],
          "description": "Default: native"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: native, lf, crlf"
        }
      },
      "description": "Checks for Windows-style line endings in the source code."
    },
    "Layout/ExtraSpacing": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowForAlignment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowBeforeTrailingComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "ForceEqualSignAlignment": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for extra/unnecessary whitespace."
    },
    "Layout/FirstArgumentIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "consistent",
            "consistent_relative_to_receiver",
            "special_for_inner_method_call",
            "special_for_inner_method_call_in_parentheses"
          ],
          "description": "Default: special_for_inner_method_call_in_parentheses"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: consistent, consistent_relative_to_receiver, special_for_inner_method_call, special_for_inner_method_call_in_parentheses"
        }
      },
      "description": "Checks the indentation of the first argument in a method call. Arguments after the first one are checked by `Layout/ArgumentAlignment`, not by this cop.\n\nFor indenting the first parameter of method _definitions_, check out `Layout/FirstParameterIndentation`.\n\nThis cop will respect `Layout/ArgumentAlignment` and will not work when `EnforcedStyle: with_fixed_indentation` is specified for `Layout/ArgumentAlignment`."
    },
    "Layout/FirstArrayElementIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "special_inside_parentheses",
            "consistent",
            "align_brackets"
          ],
          "description": "Default: special_inside_parentheses"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: special_inside_parentheses, consistent, align_brackets"
        }
      },
      "description": "Checks the indentation of the first element in an array literal where the opening bracket and the first element are on separate lines. The other elements' indentations are handled by the ArrayAlignment cop.\n\nBy default, array literals that are arguments in a method call with parentheses, and where the opening square bracket of the array is on the same line as the opening parenthesis of the method call, shall have their first element indented one step (two spaces) more than the position inside the opening parenthesis.\n\nOther array literals shall have their first element indented one step more than the start of the line where the opening square bracket is.\n\nThis default style is called 'special_inside_parentheses'. Alternative styles are 'consistent' and 'align_brackets'. Here are examples:"
    },
    "Layout/FirstArrayElementLineBreak": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for a line break before the first element in a multi-line array."
    },
    "Layout/FirstHashElementIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "special_inside_parentheses",
            "consistent",
            "align_braces"
          ],
          "description": "Default: special_inside_parentheses"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: special_inside_parentheses, consistent, align_braces"
        }
      },
      "description": "Checks the indentation of the first key in a hash literal where the opening brace and the first key are on separate lines. The other keys' indentations are handled by the HashAlignment cop.\n\nBy default, Hash literals that are arguments in a method call with parentheses, and where the opening curly brace of the hash is on the same line as the opening parenthesis of the method call, shall have their first key indented one step (two spaces) more than the position inside the opening parenthesis.\n\nOther hash literals shall have their first key indented one step more than the start of the line where the opening curly brace is.\n\nThis default style is called 'special_inside_parentheses'. Alternative styles are 'consistent' and 'align_braces'. Here are examples:"
    },
    "Layout/FirstHashElementLineBreak": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for a line break before the first element in a multi-line hash."
    },
    "Layout/FirstMethodArgumentLineBreak": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for a line break before the first argument in a multi-line method call."
    },
    "Layout/FirstMethodParameterLineBreak": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for a line break before the first parameter in a multi-line method parameter definition."
    },
    "Layout/FirstParameterIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "consistent",
            "align_parentheses"
          ],
          "description": "Default: consistent"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: consistent, align_parentheses"
        }
      },
      "description": "Checks the indentation of the first parameter in a method definition. Parameters after the first one are checked by Layout/ParameterAlignment, not by this cop.\n\nFor indenting the first argument of method _calls_, check out Layout/FirstArgumentIndentation, which supports options related to nesting that are irrelevant for method _definitions_."
    },
    "Layout/HashAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedHashRocketStyle": {
          "enum": [
            "key",
            "separator",
            "table"
          ],
          "description": "Default: key"
        },
        "EnforcedColonStyle": {
          "enum": [
            "key",
            "separator",
            "table"
          ],
          "description": "Default: key"
        },
        "EnforcedLastArgumentHashStyle": {
          "enum": [
            "always_inspect",
            "always_ignore",
            "ignore_implicit",
            "ignore_explicit"
          ],
          "description": "Default: always_inspect"
        },
        "AllowMultipleStyles": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedHashRocketStyles": {
          "type": "array",
          "description": "Default: key, separator, table"
        },
        "SupportedColonStyles": {
          "type": "array",
          "description": "Default: key, separator, table"
        },
        "SupportedLastArgumentHashStyles": {
          "type": "array",
          "description": "Default: always_inspect, always_ignore, ignore_implicit, ignore_explicit"
        }
      },
      "description": "Check that the keys, separators, and values of a multi-line hash literal are aligned according to configuration. The configuration options are:\n\n - key (left align keys, one space before hash rockets and values)\n\n - separator (align hash rockets and colons, right align keys)\n\n - table (left align keys, hash rockets, and values)\n\nThe treatment of hashes passed as the last argument to a method call can also be configured. The options are:\n\n - always_inspect\n\n - always_ignore\n\n - ignore_implicit (without curly braces)\n\nAlternatively you can specify multiple allowed styles. That's done by passing a list of styles to EnforcedStyles."
    },
    "Layout/HeredocArgumentClosingParenthesis": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for the placement of the closing parenthesis in a method call that passes a HEREDOC string as an argument. It should be placed at the end of the line containing the opening HEREDOC tag."
    },
    "Layout/HeredocIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks the indentation of the here document bodies. The bodies are indented one step.\n\nNote: When ``Layout/LineLength``'s `AllowHeredoc` is false (not default),       this cop does not add any offenses for long here documents to       avoid `Layout/LineLength`'s offenses."
    },
    "Layout/IndentationConsistency": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "normal",
            "indented_internal_methods"
          ],
          "description": "Default: normal"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: normal, indented_internal_methods"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://edgeguides.rubyonrails.org/contributing_to_ruby_on_rails.html#follow-the-coding-conventions"
        }
      },
      "description": "Checks for inconsistent indentation.\n\nThe difference between `indented_internal_methods` and `normal` is that the `indented_internal_methods` style prescribes that in classes and modules the `protected` and `private` modifier keywords shall be indented the same as public methods and that protected and private members shall be indented one step more than the modifiers. Other than that, both styles mean that entities on the same logical depth shall have the same indentation."
    },
    "Layout/IndentationStyle": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "EnforcedStyle": {
          "enum": [
            "spaces",
            "tabs"
          ],
          "description": "Default: spaces"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: spaces, tabs"
        }
      },
      "description": "Checks that the indentation method is consistent. Either tabs only or spaces only are used for indentation."
    },
    "Layout/IndentationWidth": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "Width": {
          "type": "integer",
          "description": "Default: 2"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for indentation that doesn't use the specified number of spaces.\n\nSee also the IndentationConsistency cop which is the companion to this one."
    },
    "Layout/InitialIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for indentation of the first non-blank non-comment line in a file."
    },
    "Layout/LeadingCommentSpace": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowDoxygenCommentStyle": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowGemfileRubyComment": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks whether comments have a leading space after the `#` denoting the start of the comment. The leading space is not required for some RDoc special syntax, like `#++`, `#--`, `#:nodoc`, `=begin`- and `=end` comments, \"shebang\" directives, or rackup options."
    },
    "Layout/LeadingEmptyLines": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for unnecessary leading blank lines at the beginning of a file."
    },
    "Layout/LineContinuationLeadingSpace": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "leading",
            "trailing"
          ],
          "description": "Default: trailing"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: leading, trailing"
        }
      },
      "description": "Checks that strings broken over multiple lines (by a backslash) contain trailing spaces instead of leading spaces (default) or leading spaces instead of trailing spaces."
    },
    "Layout/LineContinuationSpacing": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that the backslash of a line continuation is separated from preceding text by exactly one space (default) or zero spaces."
    },
    "Layout/LineEndStringConcatenationIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "aligned",
            "indented"
          ],
          "description": "Default: aligned"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: aligned, indented"
        }
      },
      "description": "Checks the indentation of the next line after a line that ends with a string literal and a backslash.\n\nIf `EnforcedStyle: aligned` is set, the concatenated string parts shall be aligned with the first part. There are some exceptions, such as implicit return values, where the concatenated string parts shall be indented regardless of `EnforcedStyle` configuration.\n\nIf `EnforcedStyle: indented` is set, it's the second line that shall be indented one step more than the first line. Lines 3 and forward shall be aligned with line 2."
    },
    "Layout/LineLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 120"
        },
        "AllowHeredoc": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowURI": {
          "type": "boolean",
          "description": "Default: true"
        },
        "URISchemes": {
          "type": "array",
          "description": "Default: http, https"
        },
        "IgnoreCopDirectives": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks the length of lines in the source code. The maximum length is configurable. The tab size is configured in the `IndentationWidth` of the `Layout/IndentationStyle` cop. It also ignores a shebang line by default.\n\nThis cop has some autocorrection capabilities. It can programmatically shorten certain long lines by inserting line breaks into expressions that can be safely split across lines. These include arrays, hashes, and method calls with argument lists.\n\nIf autocorrection is enabled, the following Layout cops are recommended to further format the broken lines. (Many of these are enabled by default.)\n\n - ArgumentAlignment\n\n - ArrayAlignment\n\n - BlockAlignment\n\n - BlockDelimiters\n\n - BlockEndNewline\n\n - ClosingParenthesisIndentation\n\n - FirstArgumentIndentation\n\n - FirstArrayElementIndentation\n\n - FirstHashElementIndentation\n\n - FirstParameterIndentation\n\n - HashAlignment\n\n - IndentationWidth\n\n - MultilineArrayLineBreaks\n\n - MultilineBlockLayout\n\n - MultilineHashBraceLayout\n\n - MultilineHashKeyLineBreaks\n\n - MultilineMethodArgumentLineBreaks\n\n - MultilineMethodParameterLineBreaks\n\n - ParameterAlignment\n\nTogether, these cops will pretty print hashes, arrays, method calls, etc. For example, let's say the max columns is 25:"
    },
    "Layout/MultilineArrayBraceLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "symmetrical",
            "new_line",
            "same_line"
          ],
          "description": "Default: symmetrical"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: symmetrical, new_line, same_line"
        }
      },
      "description": "Checks that the closing brace in an array literal is either on the same line as the last array element or on a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf an array's opening brace is on the same line as the first element of the array, then the closing brace should be on the same line as the last element of the array.\n\nIf an array's opening brace is on the line above the first element of the array, then the closing brace should be on the line below the last element of the array.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line array literal must be on the line after the last element of the array.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line array literal must be on the same line as the last element of the array."
    },
    "Layout/MultilineArrayLineBreaks": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Ensures that each item in a multi-line array starts on a separate line."
    },
    "Layout/MultilineAssignmentLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "same_line",
            "new_line"
          ],
          "description": "Default: new_line"
        },
        "SupportedTypes": {
          "type": "array",
          "description": "Default: block, case, class, if, kwbegin, module"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: same_line, new_line"
        }
      },
      "description": "Checks whether the multiline assignments have a newline after the assignment operator."
    },
    "Layout/MultilineBlockLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks whether the multiline do end blocks have a newline after the start of the block. Additionally, it checks whether the block arguments, if any, are on the same line as the start of the block. Putting block arguments on separate lines, because the whole line would otherwise be too long, is accepted."
    },
    "Layout/MultilineHashBraceLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "symmetrical",
            "new_line",
            "same_line"
          ],
          "description": "Default: symmetrical"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: symmetrical, new_line, same_line"
        }
      },
      "description": "Checks that the closing brace in a hash literal is either on the same line as the last hash element, or a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf a hash's opening brace is on the same line as the first element of the hash, then the closing brace should be on the same line as the last element of the hash.\n\nIf a hash's opening brace is on the line above the first element of the hash, then the closing brace should be on the line below the last element of the hash.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line hash literal must be on the line after the last element of the hash.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line hash literal must be on the same line as the last element of the hash."
    },
    "Layout/MultilineHashKeyLineBreaks": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Ensures that each key in a multi-line hash starts on a separate line."
    },
    "Layout/MultilineMethodArgumentLineBreaks": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Ensures that each argument in a multi-line method call starts on a separate line.\n\nThis cop does not move the first argument, if you want that to be on a separate line, see `Layout/FirstMethodArgumentLineBreak`."
    },
    "Layout/MultilineMethodCallBraceLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "symmetrical",
            "new_line",
            "same_line"
          ],
          "description": "Default: symmetrical"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: symmetrical, new_line, same_line"
        }
      },
      "description": "Checks that the closing brace in a method call is either on the same line as the last method argument, or a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf a method call's opening brace is on the same line as the first argument of the call, then the closing brace should be on the same line as the last argument of the call.\n\nIf an method call's opening brace is on the line above the first argument of the call, then the closing brace should be on the line below the last argument of the call.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line method call must be on the line after the last argument of the call.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line method call must be on the same line as the last argument of the call."
    },
    "Layout/MultilineMethodCallIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "aligned",
            "indented",
            "indented_relative_to_receiver"
          ],
          "description": "Default: aligned"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: aligned, indented, indented_relative_to_receiver"
        }
      },
      "description": "Checks the indentation of the method name part in method calls that span more than one line."
    },
    "Layout/MultilineMethodDefinitionBraceLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "symmetrical",
            "new_line",
            "same_line"
          ],
          "description": "Default: symmetrical"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: symmetrical, new_line, same_line"
        }
      },
      "description": "Checks that the closing brace in a method definition is either on the same line as the last method parameter, or a new line.\n\nWhen using the `symmetrical` (default) style:\n\nIf a method definition's opening brace is on the same line as the first parameter of the definition, then the closing brace should be on the same line as the last parameter of the definition.\n\nIf an method definition's opening brace is on the line above the first parameter of the definition, then the closing brace should be on the line below the last parameter of the definition.\n\nWhen using the `new_line` style:\n\nThe closing brace of a multi-line method definition must be on the line after the last parameter of the definition.\n\nWhen using the `same_line` style:\n\nThe closing brace of a multi-line method definition must be on the same line as the last parameter of the definition."
    },
    "Layout/MultilineMethodParameterLineBreaks": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowMultilineFinalElement": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Ensures that each parameter in a multi-line method definition starts on a separate line.\n\nThis cop does not move the first argument, if you want that to be on a separate line, see `Layout/FirstMethodParameterLineBreak`."
    },
    "Layout/MultilineOperationIndentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "aligned",
            "indented"
          ],
          "description": "Default: aligned"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: aligned, indented"
        }
      },
      "description": "Checks the indentation of the right hand side operand in binary operations that span more than one line.\n\nThe `aligned` style checks that operators are aligned if they are part of an `if` or `while` condition, an explicit `return` statement, etc. In other contexts, the second operand should be indented regardless of enforced style."
    },
    "Layout/ParameterAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "with_first_parameter",
            "with_fixed_indentation"
          ],
          "description": "Default: with_first_parameter"
        },
        "IndentationWidth": {
          "type": "integer",
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: with_first_parameter, with_fixed_indentation"
        }
      },
      "description": "Here we check if the parameters on a multi-line method call or definition are aligned.\n\nTo set the alignment of the first argument, use the cop FirstParameterIndentation."
    },
    "Layout/RedundantLineBreak": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "InspectBlocks": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks whether certain expressions, e.g. method calls, that could fit completely on a single line, are broken up into multiple lines unnecessarily."
    },
    "Layout/RescueEnsureAlignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks whether the rescue and ensure keywords are aligned properly."
    },
    "Layout/SingleLineBlockChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks if method calls are chained onto single line blocks. It considers that a line break before the dot improves the readability of the code."
    },
    "Layout/SpaceAfterColon": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for colon (:) not followed by some kind of space. N.B. this cop does not handle spaces after a ternary operator, which are instead handled by Layout/SpaceAroundOperators."
    },
    "Layout/SpaceAfterComma": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for comma (,) not followed by some kind of space."
    },
    "Layout/SpaceAfterMethodName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for space between a method name and a left parenthesis in defs."
    },
    "Layout/SpaceAfterNot": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for space after `!`."
    },
    "Layout/SpaceAfterSemicolon": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for semicolon (;) not followed by some kind of space."
    },
    "Layout/SpaceAroundBlockParameters": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyleInsidePipes": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: no_space"
        },
        "SupportedStylesInsidePipes": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks the spacing inside and after block parameters pipes. Line breaks inside parameter pipes are checked by `Layout/MultilineBlockLayout` and not by this cop."
    },
    "Layout/SpaceAroundEqualsInParameterDefault": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that the equals signs in parameter default assignments have or don't have surrounding space depending on configuration."
    },
    "Layout/SpaceAroundKeyword": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks the spacing around the keywords."
    },
    "Layout/SpaceAroundMethodCallOperator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks method call operators to not have spaces around them."
    },
    "Layout/SpaceAroundOperators": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowForAlignment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "EnforcedStyleForExponentOperator": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: no_space"
        },
        "SupportedStylesForExponentOperator": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that operators have space around them, except for ** which should or shouldn't have surrounding space depending on configuration. It allows vertical alignment consisting of one or more whitespace around operators.\n\nThis cop has `AllowForAlignment` option. When `true`, allows most uses of extra spacing if the intent is to align with an operator on the previous or next line, not counting empty lines or comment lines."
    },
    "Layout/SpaceBeforeBlockBraces": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: space"
        },
        "EnforcedStyleForEmptyBraces": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        },
        "SupportedStylesForEmptyBraces": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that block braces have or don't have a space before the opening brace depending on configuration."
    },
    "Layout/SpaceBeforeBrackets": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for space between the name of a receiver and a left brackets."
    },
    "Layout/SpaceBeforeComma": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for comma (,) preceded by space."
    },
    "Layout/SpaceBeforeComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for missing space between a token and a comment on the same line."
    },
    "Layout/SpaceBeforeFirstArg": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowForAlignment": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks that exactly one space is used between a method name and the first argument for method calls without parentheses.\n\nAlternatively, extra spaces can be added to align the argument with something on a preceding or following line, if the AllowForAlignment config parameter is true."
    },
    "Layout/SpaceBeforeSemicolon": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for semicolon (;) preceded by space."
    },
    "Layout/SpaceInLambdaLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "require_no_space",
            "require_space"
          ],
          "description": "Default: require_no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: require_no_space, require_space"
        }
      },
      "description": "Checks for spaces between `->` and opening parameter parenthesis (`(`) in lambda literals."
    },
    "Layout/SpaceInsideArrayLiteralBrackets": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "space",
            "no_space",
            "compact"
          ],
          "description": "Default: no_space"
        },
        "EnforcedStyleForEmptyBrackets": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space, compact"
        },
        "SupportedStylesForEmptyBrackets": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that brackets used for array literals have or don't have surrounding space depending on configuration."
    },
    "Layout/SpaceInsideArrayPercentLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for unnecessary additional spaces inside array percent literals (i.e. %i/%w).\n\nNote that blank percent literals (e.g. `%i( )`) are checked by `Layout/SpaceInsidePercentLiteralDelimiters`."
    },
    "Layout/SpaceInsideBlockBraces": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: space"
        },
        "EnforcedStyleForEmptyBraces": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: no_space"
        },
        "SpaceBeforeBlockParameters": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        },
        "SupportedStylesForEmptyBraces": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that block braces have or don't have surrounding space inside them on configuration. For blocks taking parameters, it checks that the left brace has or doesn't have trailing space depending on configuration."
    },
    "Layout/SpaceInsideHashLiteralBraces": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "space",
            "no_space",
            "compact"
          ],
          "description": "Default: space"
        },
        "EnforcedStyleForEmptyBraces": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space, compact"
        },
        "SupportedStylesForEmptyBraces": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that braces used for hash literals have or don't have surrounding space depending on configuration."
    },
    "Layout/SpaceInsideParens": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "space",
            "compact",
            "no_space"
          ],
          "description": "Default: no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, compact, no_space"
        }
      },
      "description": "Checks for spaces inside ordinary round parentheses."
    },
    "Layout/SpaceInsidePercentLiteralDelimiters": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for unnecessary additional spaces inside the delimiters of %i/%w/%x literals."
    },
    "Layout/SpaceInsideRangeLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for spaces inside range literals."
    },
    "Layout/SpaceInsideReferenceBrackets": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: no_space"
        },
        "EnforcedStyleForEmptyBrackets": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        },
        "SupportedStylesForEmptyBrackets": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks that reference brackets have or don't have surrounding space depending on configuration."
    },
    "Layout/SpaceInsideStringInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "space",
            "no_space"
          ],
          "description": "Default: no_space"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: space, no_space"
        }
      },
      "description": "Checks for whitespace within string interpolations."
    },
    "Layout/TrailingEmptyLines": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "final_newline",
            "final_blank_line"
          ],
          "description": "Default: final_newline"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: final_newline, final_blank_line"
        }
      },
      "description": "Looks for trailing blank lines and a final newline in the source code."
    },
    "Layout/TrailingWhitespace": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowInHeredoc": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for trailing whitespace in the source code."
    },
    "Lint": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Lint' department"
    },
    "Lint/AmbiguousAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for mistyped shorthand assignments."
    },
    "Lint/AmbiguousBlockAssociation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for ambiguous block association with method when param passed without parentheses.\n\nThis cop can customize allowed methods with `AllowedMethods`. By default, there are no methods to allowed."
    },
    "Lint/AmbiguousOperator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for ambiguous operators in the first argument of a method invocation without parentheses."
    },
    "Lint/AmbiguousOperatorPrecedence": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Looks for expressions containing multiple binary operators where precedence is ambiguous due to lack of parentheses. For example, in `1 + 2 * 3`, the multiplication will happen before the addition, but lexically it appears that the addition will happen first.\n\nThe cop does not consider unary operators (ie. `!a` or `-b`) or comparison operators (ie. `a =~ b`) because those are not ambiguous.\n\nRanges are handled by `Lint/AmbiguousRange`."
    },
    "Lint/AmbiguousRange": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "RequireParenthesesForMethodChains": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for ambiguous ranges.\n\nRanges have quite low precedence, which leads to unexpected behavior when using a range with other operators. This cop avoids that by making ranges explicit by requiring parenthesis around complex range boundaries (anything that is not a literal: numerics, strings, symbols, etc.).\n\nThis cop can be configured with `RequireParenthesesForMethodChains` in order to specify whether method chains (including `self.foo`) should be wrapped in parens by this cop.\n\nRegardless of this configuration, if a method receiver is a basic literal value, it will be wrapped in order to prevent the ambiguity of `1..2.to_a`."
    },
    "Lint/AmbiguousRegexpLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for ambiguous regexp literals in the first argument of a method invocation without parentheses."
    },
    "Lint/AssignmentInCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowSafeAssignment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for assignments in the conditions of if/while/until.\n\n`AllowSafeAssignment` option for safe assignment. By safe assignment we mean putting parentheses around an assignment to indicate \"I know I'm using an assignment as a condition. It's not a mistake.\""
    },
    "Lint/BigDecimalNew": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "`BigDecimal.new()` is deprecated since BigDecimal 1.3.3. This cop identifies places where `BigDecimal.new()` can be replaced by `BigDecimal()`."
    },
    "Lint/BinaryOperatorWithIdenticalOperands": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where binary operator has identical operands.\n\nIt covers arithmetic operators: `-`, `/`, `%`; comparison operators: `==`, `===`, `=~`, `>`, `>=`, `<`, `<=`; bitwise operators: `|`, `^`, `&`; boolean operators: `&&`, `||` and \"spaceship\" operator - `<=>`.\n\nSimple arithmetic operations are allowed by this cop: `+`, `*`, `**`, `<<` and `>>`. Although these can be rewritten in a different way, it should not be necessary to do so. This does not include operations such as `-` or `/` where the result will always be the same (`x - x` will always be 0; `x / x` will always be 1), and thus are legitimate offenses."
    },
    "Lint/BooleanSymbol": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for `:true` and `:false` symbols. In most cases it would be a typo."
    },
    "Lint/CircularArgumentReference": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for circular argument references in optional keyword arguments and optional ordinal arguments.\n\nThis cop mirrors a warning produced by MRI since 2.2."
    },
    "Lint/ConstantDefinitionInBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: enums"
        }
      },
      "description": "Do not define constants within a block, since the block's scope does not isolate or namespace the constant in any way.\n\nIf you are trying to define that constant once, define it outside of the block instead, or use a variable or method if defining the constant in the outer scope would be problematic.\n\nFor meta-programming, use `const_set`."
    },
    "Lint/ConstantOverwrittenInRescue": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for overwriting an exception with an exception result by use `rescue =>`.\n\nYou intended to write as `rescue StandardError`. However, you have written `rescue => StandardError`. In that case, the result of `rescue` will overwrite `StandardError`."
    },
    "Lint/ConstantResolution": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Only": {
          "type": "array",
          "description": "Default: []"
        },
        "Ignore": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Check that certain constants are fully qualified.\n\nThis is not enabled by default because it would mark a lot of offenses unnecessarily.\n\nGenerally, gems should fully qualify all constants to avoid conflicts with the code that uses the gem. Enable this cop without using `Only`/`Ignore`\n\nLarge projects will over time end up with one or two constant names that are problematic because of a conflict with a library or just internally using the same name a namespace and a class. To avoid too many unnecessary offenses, Enable this cop with `Only: [The, Constant, Names, Causing, Issues]`\n\n`Style/RedundantConstantBase` cop is disabled if this cop is enabled to prevent conflicting rules. Because it respects user configurations that want to enable this cop which is disabled by default."
    },
    "Lint/Debugger": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "DebuggerMethods": {
          "description": "Default: {\"Kernel\"â‡’[\"binding.irb\", \"Kernel.binding.irb\"], \"Byebug\"â‡’[\"byebug\", \"remote_byebug\", \"Kernel.byebug\", \"Kernel.remote_byebug\"], \"Capybara\"â‡’[\"save_and_open_page\", \"save_and_open_screenshot\"], \"debug.rb\"â‡’[\"binding.b\", \"binding.break\", \"Kernel.binding.b\", \"Kernel.binding.break\"], \"Pry\"â‡’[\"binding.pry\", \"binding.remote_pry\", \"binding.pry_remote\", \"Kernel.binding.pry\", \"Kernel.binding.remote_pry\", \"Kernel.binding.pry_remote\", \"Pry.rescue\", \"pry\"], \"Rails\"â‡’[\"debugger\", \"Kernel.debugger\"], \"RubyJard\"â‡’[\"jard\"], \"WebConsole\"â‡’[\"binding.console\"]}"
        }
      },
      "description": "Checks for debug calls (such as `debugger` or `binding.pry`) that should not be kept for production code.\n\nThe cop can be configured using `DebuggerMethods`. By default, a number of gems debug entrypoints are configured (`Kernel`, `Byebug`, `Capybara`, `debug.rb`, `Pry`, `Rails`, `RubyJard`, and `WebConsole`). Additional methods can be added.\n\nSpecific default groups can be disabled if necessary:\n\nLint/Debugger:   DebuggerMethods:     WebConsole: ~\n\nYou can also add your own methods by adding a new category:\n\nLint/Debugger:   DebuggerMethods:     MyDebugger:       MyDebugger.debug_this"
    },
    "Lint/DeprecatedClassMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of the deprecated class method usages."
    },
    "Lint/DeprecatedConstants": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "DeprecatedConstants": {
          "description": "Default: {\"NIL\"â‡’{\"Alternative\"â‡’\"nil\", \"DeprecatedVersion\"â‡’\"2.4\"}, \"TRUE\"â‡’{\"Alternative\"â‡’\"true\", \"DeprecatedVersion\"â‡’\"2.4\"}, \"FALSE\"â‡’{\"Alternative\"â‡’\"false\", \"DeprecatedVersion\"â‡’\"2.4\"}, \"Net::HTTPServerException\"â‡’{\"Alternative\"â‡’\"Net::HTTPClientException\", \"DeprecatedVersion\"â‡’\"2.6\"}, \"Random::DEFAULT\"â‡’{\"Alternative\"â‡’\"Random.new\", \"DeprecatedVersion\"â‡’\"3.0\"}, \"Struct::Group\"â‡’{\"Alternative\"â‡’\"Etc::Group\", \"DeprecatedVersion\"â‡’\"3.0\"}, \"Struct::Passwd\"â‡’{\"Alternative\"â‡’\"Etc::Passwd\", \"DeprecatedVersion\"â‡’\"3.0\"}}"
        }
      },
      "description": "Checks for deprecated constants.\n\nIt has `DeprecatedConstants` config. If there is an alternative method, you can set alternative value as `Alternative`. And you can set the deprecated version as `DeprecatedVersion`. These options can be omitted if they are not needed.\n\n  DeprecatedConstants:\n    'DEPRECATED_CONSTANT':\n      Alternative: 'alternative_value'\n      DeprecatedVersion: 'deprecated_version'\n\nBy default, `NIL`, `TRUE`, `FALSE`, `Net::HTTPServerException, `Random::DEFAULT`, `Struct::Group`, and `Struct::Passwd` are configured."
    },
    "Lint/DeprecatedOpenSSLConstant": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Algorithmic constants for `OpenSSL::Cipher` and `OpenSSL::Digest` deprecated since OpenSSL version 2.2.0. Prefer passing a string instead."
    },
    "Lint/DisjunctiveAssignmentInConstructor": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks constructors for disjunctive assignments (`||=`) that should be plain assignments.\n\nSo far, this cop is only concerned with disjunctive assignment of instance variables.\n\nIn ruby, an instance variable is nil until a value is assigned, so the disjunction is unnecessary. A plain assignment has the same effect."
    },
    "Lint/DuplicateBranch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoreLiteralBranches": {
          "type": "boolean",
          "description": "Default: false"
        },
        "IgnoreConstantBranches": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks that there are no repeated bodies within `if/unless`, `case-when`, `case-in` and `rescue` constructs.\n\nWith `IgnoreLiteralBranches: true`, branches are not registered as offenses if they return a basic literal value (string, symbol, integer, float, rational, complex, `true`, `false`, or `nil`), or return an array, hash, regexp or range that only contains one of the above basic literal values.\n\nWith `IgnoreConstantBranches: true`, branches are not registered as offenses if they return a constant value."
    },
    "Lint/DuplicateCaseCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that there are no repeated conditions used in case 'when' expressions."
    },
    "Lint/DuplicateElsifCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that there are no repeated conditions used in if 'elsif'."
    },
    "Lint/DuplicateHashKey": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for duplicated keys in hash literals. This cop considers both primitive types and constants for the hash keys.\n\nThis cop mirrors a warning in Ruby 2.2."
    },
    "Lint/DuplicateMagicComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for duplicated magic comments."
    },
    "Lint/DuplicateMatchPattern": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that there are no repeated patterns used in `in` keywords."
    },
    "Lint/DuplicateMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for duplicated instance (or singleton) method definitions."
    },
    "Lint/DuplicateRegexpCharacterClassElement": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for duplicate elements in Regexp character classes."
    },
    "Lint/DuplicateRequire": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for duplicate ``require``s and ``require_relative``s."
    },
    "Lint/DuplicateRescueException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that there are no repeated exceptions used in 'rescue' expressions."
    },
    "Lint/EachWithObjectArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks if each_with_object is called with an immutable argument. Since the argument is the object that the given block shall make calls on to build something based on the enumerable that each_with_object iterates over, an immutable argument makes no sense. It's definitely a bug."
    },
    "Lint/ElseLayout": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for odd `else` block layout - like having an expression on the same line as the `else` keyword, which is usually a mistake.\n\nIts autocorrection tweaks layout to keep the syntax. So, this autocorrection is compatible correction for bad case syntax, but if your code makes a mistake with `elsif` and `else`, you will have to correct it manually."
    },
    "Lint/EmptyBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowEmptyLambdas": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for blocks without a body. Such empty blocks are typically an oversight or we should provide a comment be clearer what we're aiming for.\n\nEmpty lambdas and procs are ignored by default.\n\nFor backwards compatibility, the configuration that allows/disallows empty lambdas and procs is called `AllowEmptyLambdas`, even though it also applies to procs."
    },
    "Lint/EmptyClass": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for classes and metaclasses without a body. Such empty classes and metaclasses are typically an oversight or we should provide a comment to be clearer what we're aiming for."
    },
    "Lint/EmptyConditionalBody": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the presence of `if`, `elsif` and `unless` branches without a body.\n\nempty `else` branches are handled by `Style/EmptyElse`."
    },
    "Lint/EmptyEnsure": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for empty `ensure` blocks"
    },
    "Lint/EmptyExpression": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the presence of empty expressions."
    },
    "Lint/EmptyFile": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Enforces that Ruby source files are not empty."
    },
    "Lint/EmptyInPattern": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for the presence of `in` pattern branches without a body."
    },
    "Lint/EmptyInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for empty interpolation."
    },
    "Lint/EmptyWhen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for the presence of `when` branches without a body."
    },
    "Lint/EnsureReturn": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for `return` from an `ensure` block. `return` from an ensure block is a dangerous code smell as it will take precedence over any exception being raised, and the exception will be silently thrown away as if it were rescued.\n\nIf you want to rescue some (or all) exceptions, best to do it explicitly"
    },
    "Lint/ErbNewArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Emulates the following Ruby warnings in Ruby 2.6.\n\n$ cat example.rb ERB.new('hi', nil, '-', '@output_buffer') $ ruby -rerb example.rb example.rb:1: warning: Passing safe_level with the 2nd argument of ERB.new is deprecated. Do not use it, and specify other arguments as keyword arguments. example.rb:1: warning: Passing trim_mode with the 3rd argument of ERB.new is deprecated. Use keyword argument like ERB.new(str, trim_mode:...) instead. example.rb:1: warning: Passing eoutvar with the 4th argument of ERB.new is deprecated. Use keyword argument like ERB.new(str, eoutvar: ...) instead.\n\nNow non-keyword arguments other than first one are softly deprecated and will be removed when Ruby 2.5 becomes EOL. `ERB.new` with non-keyword arguments is deprecated since ERB 2.2.0. Use `:trim_mode` and `:eoutvar` keyword arguments to `ERB.new`. This cop identifies places where `ERB.new(str, trim_mode, eoutvar)` can be replaced by `ERB.new(str, :trim_mode: trim_mode, eoutvar: eoutvar)`."
    },
    "Lint/FlipFlop": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for uses of flip-flop operator based on the Ruby Style Guide.\n\nHere is the history of flip-flops in Ruby. flip-flop operator is deprecated in Ruby 2.6.0 and the deprecation has been reverted by Ruby 2.7.0 and backported to Ruby 2.6. See: https://bugs.ruby-lang.org/issues/5400"
    },
    "Lint/FloatComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the presence of precise comparison of floating point numbers.\n\nFloating point values are inherently inaccurate, and comparing them for exact equality is almost never the desired semantics. Comparison via the `==/!=` operators checks floating-point value representation to be exactly the same, which is very unlikely if you perform any arithmetic operations involving precision loss."
    },
    "Lint/FloatOutOfRange": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies Float literals which are, like, really really really really really really really really big. Too big. No-one needs Floats that big. If you need a float that big, something is wrong with you."
    },
    "Lint/FormatParameterMismatch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "This lint sees if there is a mismatch between the number of expected fields for format/sprintf/#% and what is actually passed as arguments.\n\nIn addition it checks whether different formats are used in the same format string. Do not mix numbered, unnumbered, and named formats in the same format string."
    },
    "Lint/HashCompareByIdentity": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Prefer using `Hash#compare_by_identity` rather than using `object_id` for hash keys.\n\nThis cop looks for hashes being keyed by objects' `object_id`, using one of these methods: `key?`, `has_key?`, `fetch`, `[]` and `[]=`."
    },
    "Lint/HeredocMethodCallPosition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for the ordering of a method call where the receiver of the call is a HEREDOC."
    },
    "Lint/IdentityComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Prefer `equal?` over `==` when comparing `object_id`.\n\n`Object#equal?` is provided to compare objects for identity, and in contrast `Object#==` is provided for the purpose of doing value comparison."
    },
    "Lint/ImplicitStringConcatenation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for implicit string concatenation of string literals which are on the same line."
    },
    "Lint/IncompatibleIoSelectWithFiberScheduler": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for `IO.select` that is incompatible with Fiber Scheduler since Ruby 3.0.\n\nWhen an array of IO objects waiting for an exception (the third argument of `IO.select`) is used as an argument, there is no alternative API, so offenses are not registered.\n\nWhen the method is successful the return value of `IO.select` is `[[IO]]`, and the return value of `io.wait_readable` and `io.wait_writable` are `self`. They are not autocorrected when assigning a return value because these types are different. It's up to user how to handle the return value."
    },
    "Lint/IneffectiveAccessModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `private` or `protected` access modifiers which are applied to a singleton method. These access modifiers do not make singleton methods private/protected. `private_class_method` can be used for that."
    },
    "Lint/InheritException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "standard_error",
            "runtime_error"
          ],
          "description": "Default: standard_error"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: standard_error, runtime_error"
        }
      },
      "description": "Looks for error classes inheriting from `Exception`. It is configurable to suggest using either `StandardError` (default) or `RuntimeError` instead."
    },
    "Lint/InterpolationCheck": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for interpolation in a single quoted string."
    },
    "Lint/LambdaWithoutLiteralBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks uses of lambda without a literal block. It emulates the following warning in Ruby 3.0:\n\n  $ ruby -vwe 'lambda(&proc {})'\n  ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-darwin19]\n  -e:1: warning: lambda without a literal block is deprecated; use the proc without\n  lambda instead\n\nThis way, proc object is never converted to lambda. Autocorrection replaces with compatible proc argument."
    },
    "Lint/LiteralAsCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for literals used as the conditions or as operands in and/or expressions serving as the conditions of if/while/until/case-when/case-in.\n\nLiterals in `case-in` condition where the match variable is used in `in` are accepted as a pattern matching."
    },
    "Lint/LiteralInInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for interpolated literals."
    },
    "Lint/Loop": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for uses of `begin...end while/until something`."
    },
    "Lint/MissingCopEnableDirective": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MaximumRangeSize": {
          "type": "number",
          "description": "Default: Infinity"
        }
      },
      "description": "Checks that there is an `# rubocop:enable ...` statement after a `# rubocop:disable ...` statement. This will prevent leaving cop disables on wide ranges of code, that latter contributors to a file wouldn't be aware of."
    },
    "Lint/MissingSuper": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedParentClasses": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for the presence of constructors and lifecycle callbacks without calls to `super`.\n\nThis cop does not consider `method_missing` (and `respond_to_missing?`) because in some cases it makes sense to overtake what is considered a missing method. In other cases, the theoretical ideal handling could be challenging or verbose for no actual gain.\n\nAutocorrection is not supported because the position of `super` cannot be determined automatically.\n\n`Object` and `BasicObject` are allowed by this cop because of their stateless nature. However, sometimes you might want to allow other parent classes from this cop, for example in the case of an abstract class that is not meant to be called with `super`. In those cases, you can use the `AllowedParentClasses` option to specify which classes should be allowed *in addition to* `Object` and `BasicObject`."
    },
    "Lint/MixedCaseRange": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for mixed-case character ranges since they include likely unintended characters.\n\nOffenses are registered for regexp character classes like `/[A-z]/` as well as range objects like `('A'..'z')`.\n\nRange objects cannot be autocorrected."
    },
    "Lint/MixedRegexpCaptureTypes": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Do not mix named captures and numbered captures in a Regexp literal because numbered capture is ignored if they're mixed. Replace numbered captures with non-capturing groupings or named captures."
    },
    "Lint/MultipleComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "In math and Python, we can use `x < y < z` style comparison to compare multiple value. However, we can't use the comparison in Ruby. However, the comparison is not syntax error. This cop checks the bad usage of comparison operators."
    },
    "Lint/NestedMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for nested method definitions."
    },
    "Lint/NestedPercentLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for nested percent literals."
    },
    "Lint/NextWithoutAccumulator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Don't omit the accumulator when calling `next` in a `reduce` block."
    },
    "Lint/NoReturnInBeginEndBlocks": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the presence of a `return` inside a `begin..end` block in assignment contexts. In this situation, the `return` will result in an exit from the current method, possibly leading to unexpected behavior."
    },
    "Lint/NonAtomicFileOperation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for non-atomic file operation. And then replace it with a nearly equivalent and atomic method.\n\nThese can cause problems that are difficult to reproduce, especially in cases of frequent file operations in parallel, such as test runs with parallel_rspec.\n\nFor examples: creating a directory if there is none, has the following problems\n\nAn exception occurs when the directory didn't exist at the time of `exist?`, but someone else created it before `mkdir` was executed.\n\nSubsequent processes are executed without the directory that should be there when the directory existed at the time of `exist?`, but someone else deleted it shortly afterwards."
    },
    "Lint/NonDeterministicRequireOrder": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "`Dir[...]` and `Dir.glob(...)` do not make any guarantees about the order in which files are returned. The final order is determined by the operating system and file system. This means that using them in cases where the order matters, such as requiring files, can lead to intermittent failures that are hard to debug. To ensure this doesn't happen, always sort the list.\n\n`Dir.glob` and `Dir[]` sort globbed results by default in Ruby 3.0. So all bad cases are acceptable when Ruby 3.0 or higher are used.\n\nThis cop will be deprecated and removed when supporting only Ruby 3.0 and higher."
    },
    "Lint/NonLocalExitFromIterator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for non-local exits from iterators without a return value. It registers an offense under these conditions:\n\n - No value is returned,\n\n - the block is preceded by a method chain,\n\n - the block has arguments,\n\n - the method which receives the block is not define_method or define_singleton_method,\n\n - the return is not contained in an inner scope, e.g. a lambda or a method definition."
    },
    "Lint/NumberConversion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "IgnoredClasses": {
          "type": "array",
          "description": "Default: Time, DateTime"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Warns the usage of unsafe number conversions. Unsafe number conversion can cause unexpected error if auto type conversion fails. Cop prefer parsing with number class instead.\n\nConversion with `Integer`, `Float`, etc. will raise an `ArgumentError` if given input that is not numeric (eg. an empty string), whereas `to_i`, etc. will try to convert regardless of input (`''.to_i => 0`). As such, this cop is disabled by default because it's not necessarily always correct to raise if a value is not numeric.\n\nSome values cannot be converted properly using one of the `Kernel` method (for instance, `Time` and `DateTime` values are allowed by this cop by default). Similarly, Rails' duration methods do not work well with `Integer()` and can be allowed with `AllowedMethods`. By default, there are no methods to allowed."
    },
    "Lint/NumberedParameterAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of numbered parameter assignment. It emulates the following warning in Ruby 2.7:\n\n  $ ruby -ve '_1 = :value'\n  ruby 2.7.2p137 (2020-10-01 revision 5445e04352) [x86_64-darwin19]\n  -e:1: warning: `_1' is reserved for numbered parameter; consider another name\n\nAssigning to a numbered parameter (from `_1` to `_9`) causes an error in Ruby 3.0.\n\n  $ ruby -ve '_1 = :value'\n  ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-darwin19]\n  -e:1: _1 is reserved for numbered parameter\n\nThe parametered parameters are from `_1` to `_9`. This cop checks `_0`, and over `_10` as well to prevent confusion."
    },
    "Lint/OrAssignmentToConstant": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for unintended or-assignment to a constant.\n\nConstants should always be assigned in the same location. And its value should always be the same. If constants are assigned in multiple locations, the result may vary depending on the order of `require`."
    },
    "Lint/OrderedMagicComments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks the proper ordering of magic comments and whether a magic comment is not placed before a shebang."
    },
    "Lint/OutOfRangeRegexpRef": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for references of Regexp captures that are out of range and thus always returns nil."
    },
    "Lint/ParenthesesAsGroupedExpression": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for space between the name of a called method and a left parenthesis."
    },
    "Lint/PercentStringArray": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for quotes and commas in %w, e.g. `%w('foo', \"bar\")`\n\nIt is more likely that the additional characters are unintended (for example, mistranslating an array of literals to percent string notation) rather than meant to be part of the resulting strings."
    },
    "Lint/PercentSymbolArray": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for colons and commas in %i, e.g. `%i(:foo, :bar)`\n\nIt is more likely that the additional characters are unintended (for example, mistranslating an array of literals to percent string notation) rather than meant to be part of the resulting symbols."
    },
    "Lint/RaiseException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedImplicitNamespaces": {
          "type": "array",
          "description": "Default: Gem"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for `raise` or `fail` statements which are raising `Exception` class.\n\nYou can specify a module name that will be an implicit namespace using `AllowedImplicitNamespaces` option. The cop cause a false positive for namespaced `Exception` when a namespace is omitted. This option can prevent the false positive by specifying a namespace to be omitted for `Exception`. Alternatively, make `Exception` a fully qualified class name with an explicit namespace."
    },
    "Lint/RandOne": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `rand(1)` calls. Such calls always return `0`."
    },
    "Lint/RedundantCopDisableDirective": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Detects instances of rubocop:disable comments that can be removed without causing any offenses to be reported. It's implemented as a cop in that it inherits from the Cop base class and calls add_offense. The unusual part of its implementation is that it doesn't have any on_* methods or an investigate method. This means that it doesn't take part in the investigation phase when the other cops do their work. Instead, it waits until it's called in a later stage of the execution. The reason it can't be implemented as a normal cop is that it depends on the results of all other cops to do its work."
    },
    "Lint/RedundantCopEnableDirective": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Detects instances of rubocop:enable comments that can be removed.\n\nWhen comment enables all cops at once `rubocop:enable all` that cop checks whether any cop was actually enabled."
    },
    "Lint/RedundantDirGlobSort": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Sort globbed results by default in Ruby 3.0. This cop checks for redundant `sort` method to `Dir.glob` and `Dir[]`."
    },
    "Lint/RedundantRegexpQuantifiers": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant quantifiers inside Regexp literals.\n\nIt is always allowed when interpolation is used in a regexp literal, because it's unknown what kind of string will be expanded as a result:\n\n/(?:a*#{interpolation})?/x"
    },
    "Lint/RedundantRequireStatement": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for unnecessary `require` statement.\n\nThe following features are unnecessary `require` statement because they are already loaded. e.g. Ruby 2.2:\n\n  ruby -ve 'p $LOADED_FEATURES.reject { |feature| %r|/| =~ feature }'\n  ruby 2.2.8p477 (2017-09-14 revision 59906) [x86_64-darwin13]\n  [\"enumerator.so\", \"rational.so\", \"complex.so\", \"thread.rb\"]\n\nBelow are the features that each `TargetRubyVersion` targets.\n\n - 2.0+ â€¦â€‹ enumerator\n\n - 2.1+ â€¦â€‹ thread\n\n - 2.2+ â€¦â€‹ Add rational and complex above\n\n - 2.5+ â€¦â€‹ Add pp above\n\n - 2.7+ â€¦â€‹ Add ruby2_keywords above\n\n - 3.1+ â€¦â€‹ Add fiber above\n\n - 3.2+ â€¦â€‹ set\n\nThis cop target those features."
    },
    "Lint/RedundantSafeNavigation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: instance_of?, kind_of?, is_a?, eql?, respond_to?, equal?"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for redundant safe navigation calls. `instance_of?`, `kind_of?`, `is_a?`, `eql?`, `respond_to?`, and `equal?` methods are checked by default. These are customizable with `AllowedMethods` option.\n\nThe `AllowedMethods` option specifies nil-safe methods, in other words, it is a method that is allowed to skip safe navigation. Note that the `AllowedMethod` option is not an option that specifies methods for which to suppress (allow) this cop's check.\n\nIn the example below, the safe navigation operator (`&.`) is unnecessary because `NilClass` has methods like `respond_to?` and `is_a?`."
    },
    "Lint/RedundantSplatExpansion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowPercentLiteralArrayArgument": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for unneeded usages of splat expansion"
    },
    "Lint/RedundantStringCoercion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for string conversion in string interpolation, `print`, `puts`, and `warn` arguments, which is redundant."
    },
    "Lint/RedundantWithIndex": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant `with_index`."
    },
    "Lint/RedundantWithObject": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant `with_object`."
    },
    "Lint/RefinementImportMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks if `include` or `prepend` is called in `refine` block. These methods are deprecated and should be replaced with `Refinement#import_methods`.\n\nIt emulates deprecation warnings in Ruby 3.1."
    },
    "Lint/RegexpAsCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for regexp literals used as `match-current-line`. If a regexp literal is in condition, the regexp matches `$_` implicitly."
    },
    "Lint/RequireParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for expressions where there is a call to a predicate method with at least one argument, where no parentheses are used around the parameter list, and a boolean operator, && or ||, is used in the last argument.\n\nThe idea behind warning for these constructs is that the user might be under the impression that the return value from the method call is an operand of &&/||."
    },
    "Lint/RequireRangeParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that a range literal is enclosed in parentheses when the end of the range is at a line break.\n\nThe following is maybe intended for `(42..)`. But, compatible is `42..do_something`. So, this cop does not provide autocorrection because it is left to user.\n\ncase condition when 42..   do_something end"
    },
    "Lint/RequireRelativeSelfPath": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses a file requiring itself with `require_relative`."
    },
    "Lint/RescueException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `rescue` blocks targeting the Exception class."
    },
    "Lint/RescueType": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Check for arguments to `rescue` that will result in a `TypeError` if an exception is raised."
    },
    "Lint/ReturnInVoidContext": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of a return with a value in a context where the value will be ignored. (initialize and setter methods)"
    },
    "Lint/SafeNavigationChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: present?, blank?, presence, try, try!, in?"
        }
      },
      "description": "The safe navigation operator returns nil if the receiver is nil. If you chain an ordinary method call after a safe navigation operator, it raises NoMethodError. We should use a safe navigation operator after a safe navigation operator. This cop checks for the problem outlined above."
    },
    "Lint/SafeNavigationConsistency": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: present?, blank?, presence, try, try!"
        }
      },
      "description": "Check to make sure that if safe navigation is used for a method call in an `&&` or `||` condition that safe navigation is used for all method calls on that same object."
    },
    "Lint/SafeNavigationWithEmpty": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks to make sure safe navigation isn't used with `empty?` in a conditional.\n\nWhile the safe navigation operator is generally a good idea, when checking `foo&.empty?` in a conditional, `foo` being `nil` will actually do the opposite of what the author intends."
    },
    "Lint/ScriptPermission": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks if a file which has a shebang line as its first line is granted execute permission."
    },
    "Lint/SelfAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for self-assignments."
    },
    "Lint/SendWithMixinArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for `send`, `public_send`, and `__send__` methods when using mix-in.\n\n`include` and `prepend` methods were private methods until Ruby 2.0, they were mixed-in via `send` method. This cop uses Ruby 2.1 or higher style that can be called by public methods. And `extend` method that was originally a public method is also targeted for style unification."
    },
    "Lint/ShadowedArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoreImplicitReferences": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for shadowed arguments.\n\nThis cop has `IgnoreImplicitReferences` configuration option. It means argument shadowing is used in order to pass parameters to zero arity `super` when `IgnoreImplicitReferences` is `true`."
    },
    "Lint/ShadowedException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for a rescued exception that get shadowed by a less specific exception being rescued before a more specific exception is rescued.\n\nAn exception is considered shadowed if it is rescued after its ancestor is, or if it and its ancestor are both rescued in the same `rescue` statement. In both cases, the more specific rescue is unnecessary because it is covered by rescuing the less specific exception. (ie. `rescue Exception, StandardError` has the same behavior whether `StandardError` is included or not, because all ``StandardError``s are rescued by `rescue Exception`)."
    },
    "Lint/ShadowingOuterLocalVariable": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of local variable names from an outer scope in block arguments or block-local variables. This mirrors the warning given by `ruby -cw` prior to Ruby 2.6: \"shadowing outer local variable - foo\".\n\nShadowing of variables in block passed to `Ractor.new` is allowed because `Ractor` should not access outer variables. eg. following style is encouraged:\n\n  [source,ruby]\n  ----\n  worker_id, pipe = env\n  Ractor.new(worker_id, pipe) do |worker_id, pipe|\n  end\n  ----"
    },
    "Lint/StructNewOverride": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks unexpected overrides of the `Struct` built-in methods via `Struct.new`."
    },
    "Lint/SuppressedException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowNil": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for `rescue` blocks with no body."
    },
    "Lint/SymbolConversion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "strict",
            "consistent"
          ],
          "description": "Default: strict"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: strict, consistent"
        }
      },
      "description": "Checks for uses of literal strings converted to a symbol where a literal symbol could be used instead.\n\nThere are two possible styles for this cop. `strict` (default) will register an offense for any incorrect usage. `consistent` additionally requires hashes to use the same style for every symbol key (ie. if any symbol key needs to be quoted it requires all keys to be quoted)."
    },
    "Lint/Syntax": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Repacks Parser's diagnostics/errors into RuboCop's offenses."
    },
    "Lint/ToEnumArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Ensures that `to_enum`/`enum_for`, called for the current method, has correct arguments."
    },
    "Lint/ToJSON": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks to make sure `#to_json` includes an optional argument. When overriding `#to_json`, callers may invoke JSON generation via `JSON.generate(your_obj)`.  Since `JSON#generate` allows for an optional argument, your method should too."
    },
    "Lint/TopLevelReturnWithArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.jb"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for top level return with arguments. If there is a top-level return statement with an argument, then the argument is always ignored. This is detected automatically since Ruby 2.7."
    },
    "Lint/TrailingCommaInAttributeDeclaration": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for trailing commas in attribute declarations, such as `#attr_reader`. Leaving a trailing comma will nullify the next method definition by overriding it with a getter method."
    },
    "Lint/TripleQuotes": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for \"triple quotes\" (strings delimited by any odd number of quotes greater than 1).\n\nRuby allows multiple strings to be implicitly concatenated by just being adjacent in a statement (ie. `\"foo\"\"bar\" == \"foobar\"`). This sometimes gives the impression that there is something special about triple quotes, but in fact it is just extra unnecessary quotes and produces the same string. Each pair of quotes produces an additional concatenated empty string, so the result is still only the \"actual\" string within the delimiters.\n\nAlthough this cop is called triple quotes, the same behavior is present for strings delimited by 5, 7, etc. quotation marks."
    },
    "Lint/UnderscorePrefixedVariableName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowKeywordBlockArguments": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for underscore-prefixed variables that are actually used.\n\nSince block keyword arguments cannot be arbitrarily named at call sites, the `AllowKeywordBlockArguments` will allow use of underscore- prefixed block keyword arguments."
    },
    "Lint/UnexpectedBlockArity": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Methods": {
          "description": "Default: {\"chunk_while\"â‡’2, \"each_with_index\"â‡’2, \"each_with_object\"â‡’2, \"inject\"â‡’2, \"max\"â‡’2, \"min\"â‡’2, \"minmax\"â‡’2, \"reduce\"â‡’2, \"slice_when\"â‡’2, \"sort\"â‡’2}"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for a block that is known to need more positional block arguments than are given (by default this is configured for `Enumerable` methods needing 2 arguments). Optional arguments are allowed, although they don't generally make sense as the default value will be used. Blocks that have no receiver, or take splatted arguments (ie. `*args`) are always accepted.\n\nKeyword arguments (including `**kwargs`) do not get counted towards this, as they are not used by the methods in question.\n\nMethod names and their expected arity can be configured like this:\n\nMethods:   inject: 2   reduce: 2"
    },
    "Lint/UnifiedInteger": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for using Fixnum or Bignum constant."
    },
    "Lint/UnmodifiedReduceAccumulator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for `reduce` or `inject` blocks where the value returned (implicitly or explicitly) does not include the accumulator. A block is considered valid as long as at least one return value includes the accumulator.\n\nIf the accumulator is not included in the return value, then the entire block will just return a transformation of the last element value, and could be rewritten as such without a loop.\n\nAlso catches instances where an index of the accumulator is returned, as this may change the type of object being retained.\n\nFor the purpose of reducing false positives, this cop only flags returns in `reduce` blocks where the element is the only variable in the expression (since we will not be able to tell what other variables relate to via static analysis)."
    },
    "Lint/UnreachableCode": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for unreachable code. The check are based on the presence of flow of control statement in non-final position in `begin` (implicit) blocks."
    },
    "Lint/UnreachableLoop": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: (?-mix:(exactly|at_least|at_most)\\(\\d+\\)\\.times)"
        }
      },
      "description": "Checks for loops that will have at most one iteration.\n\nA loop that can never reach the second iteration is a possible error in the code. In rare cases where only one iteration (or at most one iteration) is intended behavior, the code should be refactored to use `if` conditionals.\n\nBlock methods that are used with ``Enumerable``s are considered to be loops.\n\n`AllowedPatterns` can be used to match against the block receiver in order to allow code that would otherwise be registered as an offense (eg. `times` used not in an `Enumerable` context)."
    },
    "Lint/UnusedBlockArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "IgnoreEmptyBlocks": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowUnusedKeywordArguments": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for unused block arguments."
    },
    "Lint/UnusedMethodArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowUnusedKeywordArguments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "IgnoreEmptyMethods": {
          "type": "boolean",
          "description": "Default: true"
        },
        "IgnoreNotImplementedMethods": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for unused method arguments."
    },
    "Lint/UriEscapeUnescape": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Identifies places where `URI.escape` can be replaced by `CGI.escape`, `URI.encode_www_form`, or `URI.encode_www_form_component` depending on your specific use case. Also this cop identifies places where `URI.unescape` can be replaced by `CGI.unescape`, `URI.decode_www_form`, or `URI.decode_www_form_component` depending on your specific use case."
    },
    "Lint/UriRegexp": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Identifies places where `URI.regexp` is obsolete and should not be used. Instead, use `URI::DEFAULT_PARSER.make_regexp`."
    },
    "Lint/UselessAccessModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "ContextCreatingMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "MethodCreatingMethods": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for redundant access modifiers, including those with no code, those which are repeated, and leading `public` modifiers in a class or module body. Conditionally-defined methods are considered as always being defined, and thus access modifiers guarding such methods are not redundant.\n\nThis cop has `ContextCreatingMethods` option. The default setting value is an empty array that means no method is specified. This setting is an array of methods which, when called, are known to create its own context in the module's current access context.\n\nIt also has `MethodCreatingMethods` option. The default setting value is an empty array that means no method is specified. This setting is an array of methods which, when called, are known to create other methods in the module's current access context."
    },
    "Lint/UselessAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for every useless assignment to local variable in every scope. The basic idea for this cop was from the warning of `ruby -cw`:\n\nassigned but unused variable - foo\n\nCurrently this cop has advanced logic that detects unreferenced reassignments and properly handles varied cases such as branch, loop, rescue, ensure, etc.\n\nGiven the assignment `foo = 1, bar = 2`, removing unused variables can lead to a syntax error, so this case is not autocorrected."
    },
    "Lint/UselessElseWithoutRescue": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for useless `else` in `begin..end` without `rescue`.\n\nThis syntax is no longer valid on Ruby 2.6 or higher."
    },
    "Lint/UselessMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for useless method definitions, specifically: empty constructors and methods just delegating to `super`."
    },
    "Lint/UselessRescue": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for useless `rescue`s, which only reraise rescued exceptions."
    },
    "Lint/UselessRuby2Keywords": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Looks for `ruby2_keywords` calls for methods that do not need it.\n\n`ruby2_keywords` should only be called on methods that accept an argument splat (`\\*args`) but do not explicit keyword arguments (`k:` or `k: true`) or a keyword splat (`**kwargs`)."
    },
    "Lint/UselessSetterCall": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for setter call to local variable as the final expression of a function definition."
    },
    "Lint/UselessTimes": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for uses of `Integer#times` that will never yield (when the integer <= 0) or that will only ever yield once (`1.times`)."
    },
    "Lint/Void": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "CheckForMethodsWithNoSideEffects": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for operators, variables, literals, lambda, proc and nonmutating methods used in void context."
    },
    "Metrics": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Metrics' department"
    },
    "Metrics/AbcSize": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "CountRepeatedAttributes": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 17"
        },
        "Reference": {
          "type": "array",
          "description": "Default: http://c2.com/cgi/wiki?AbcMetric, https://en.wikipedia.org/wiki/ABC_Software_Metric"
        }
      },
      "description": "Checks that the ABC size of methods is not higher than the configured maximum. The ABC size is based on assignments, branches (method calls), and conditions. See http://c2.com/cgi/wiki?AbcMetric and https://en.wikipedia.org/wiki/ABC_Software_Metric.\n\nInterpreting ABC size:\n\n - â‡ 17 satisfactory\n\n - 18..30 unsatisfactory\n\n - > 30 dangerous\n\nYou can have repeated \"attributes\" calls count as a single \"branch\". For this purpose, attributes are any method with no argument; no attempt is meant to distinguish actual `attr_reader` from other methods.\n\nThis cop also takes into account `AllowedMethods` (defaults to `[]`) And `AllowedPatterns` (defaults to `[]`)"
    },
    "Metrics/BlockLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemspec"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CountComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 25"
        },
        "CountAsOne": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: refine"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks if the length of a block exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable. The cop can be configured to ignore blocks passed to certain methods.\n\nYou can set constructs you want to fold with `CountAsOne`. Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct will be counted as one line regardless of its actual size.\n\nThe `ExcludedMethods` configuration is deprecated and only kept for backwards compatibility. Please use `AllowedMethods` and `AllowedPatterns` instead. By default, there are no methods to allowed.\n\nThis cop does not apply for `Struct` definitions."
    },
    "Metrics/BlockNesting": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CountBlocks": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 3"
        }
      },
      "description": "Checks for excessive nesting of conditional and looping constructs.\n\nYou can configure if blocks are considered using the `CountBlocks` option. When set to `false` (the default) blocks are not counted towards the nesting level. Set to `true` to count blocks as well.\n\nThe maximum level of nesting allowed is configurable."
    },
    "Metrics/ClassLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CountComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 100"
        },
        "CountAsOne": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks if the length of a class exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable.\n\nYou can set constructs you want to fold with `CountAsOne`. Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct will be counted as one line regardless of its actual size.\n\nThis cop also applies for `Struct` definitions."
    },
    "Metrics/CollectionLiteralLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "LengthThreshold": {
          "type": "integer",
          "description": "Default: 250"
        }
      },
      "description": "Checks for literals with extremely many entries. This is indicative of configuration or data that may be better extracted somewhere else, like a database, fetched from an API, or read from a non-code file (CSV, JSON, YAML, etc.)."
    },
    "Metrics/CyclomaticComplexity": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 7"
        }
      },
      "description": "Checks that the cyclomatic complexity of methods is not higher than the configured maximum. The cyclomatic complexity is the number of linearly independent paths through a method. The algorithm counts decision points and adds one.\n\nAn if statement (or unless or ?:) increases the complexity by one. An else branch does not, since it doesn't add a decision point. The && operator (or keyword and) can be converted to a nested if statement, and ||/or is shorthand for a sequence of ifs, so they also add one. Loops can be said to have an exit condition, so they add one. Blocks that are calls to builtin iteration methods (e.g. `ary.map{...}) also add one, others are ignored.\n\n  def each_child_node(*types)               # count begins: 1\n    unless block_given?                     # unless: +1\n      return to_enum(__method__, *types)\n\n  children.each do |child|                # each{}: +1\n    next unless child.is_a?(Node)         # unless: +1\n\n    yield child if types.empty? ||        # if: +1, ||: +1\n                   types.include?(child.type)\n  end\n\n    self\n  end                                       # total: 6"
    },
    "Metrics/MethodLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CountComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 10"
        },
        "CountAsOne": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks if the length of a method exceeds some maximum value. Comment lines can optionally be allowed. The maximum allowed length is configurable.\n\nYou can set constructs you want to fold with `CountAsOne`. Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct will be counted as one line regardless of its actual size.\n\nThe `ExcludedMethods` and `IgnoredMethods` configuration is deprecated and only kept for backwards compatibility. Please use `AllowedMethods` and `AllowedPatterns` instead. By default, there are no methods to allowed."
    },
    "Metrics/ModuleLength": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "CountComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 100"
        },
        "CountAsOne": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks if the length of a module exceeds some maximum value. Comment lines can optionally be ignored. The maximum allowed length is configurable.\n\nYou can set constructs you want to fold with `CountAsOne`. Available are: 'array', 'hash', 'heredoc', and 'method_call'. Each construct will be counted as one line regardless of its actual size."
    },
    "Metrics/ParameterLists": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 5"
        },
        "CountKeywordArgs": {
          "type": "boolean",
          "description": "Default: true"
        },
        "MaxOptionalParameters": {
          "type": "integer",
          "description": "Default: 3"
        }
      },
      "description": "Checks for methods with too many parameters.\n\nThe maximum number of parameters is configurable. Keyword arguments can optionally be excluded from the total count, as they add less complexity than positional or optional parameters.\n\nAny number of arguments for `initialize` method inside a block of `Struct.new` and `Data.define` like this is always allowed:\n\nStruct.new(:one, :two, :three, :four, :five, keyword_init: true) do   def initialize(one:, two:, three:, four:, five:)   end end\n\nThis is because checking the number of arguments of the `initialize` method does not make sense.\n\nExplicit block argument `&block` is not counted to prevent erroneous change that is avoided by making block argument implicit.\n\nThis cop also checks for the maximum number of optional parameters. This can be configured using the `MaxOptionalParameters` config option."
    },
    "Metrics/PerceivedComplexity": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 8"
        }
      },
      "description": "Tries to produce a complexity score that's a measure of the complexity the reader experiences when looking at a method. For that reason it considers `when` nodes as something that doesn't add as much complexity as an `if` or a `&&`. Except if it's one of those special `case`/`when` constructs where there's no expression after `case`. Then the cop treats it as an `if`/`elsif`/`elsif`... and lets all the `when` nodes count. In contrast to the CyclomaticComplexity cop, this cop considers `else` nodes as adding complexity."
    },
    "Migration": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Migration' department"
    },
    "Migration/DepartmentName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Check that cop names in rubocop:disable comments are given with department name."
    },
    "Naming": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Naming' department"
    },
    "Naming/AccessorMethodName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Makes sure that accessor methods are named properly. Applies to both instance and class methods.\n\nOffenses are only registered for methods with the expected arity. Getters (`get_attribute`) must have no arguments to be registered, and setters (`set_attribute(value)`) must have exactly one."
    },
    "Naming/AsciiIdentifiers": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AsciiConstants": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for non-ascii characters in identifier and constant names. Identifiers are always checked and whether constants are checked can be controlled using AsciiConstants config."
    },
    "Naming/BinaryOperatorParameterName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Makes sure that certain binary operator methods have their sole  parameter named `other`."
    },
    "Naming/BlockForwarding": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "anonymous",
            "explicit"
          ],
          "description": "Default: anonymous"
        },
        "BlockForwardingName": {
          "type": "string",
          "description": "Default: block"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: anonymous, explicit"
        }
      },
      "description": "In Ruby 3.1, anonymous block forwarding has been added.\n\nThis cop identifies places where `do_something(&block)` can be replaced by `do_something(&)`.\n\nIt also supports the opposite style by alternative `explicit` option. You can specify the block variable name for autocorrection with `BlockForwardingName`. The default variable name is `block`. If the name is already in use, it will not be autocorrected."
    },
    "Naming/BlockParameterName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MinNameLength": {
          "type": "integer",
          "description": "Default: 1"
        },
        "AllowNamesEndingInNumbers": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedNames": {
          "type": "array",
          "description": "Default: []"
        },
        "ForbiddenNames": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks block parameter names for how descriptive they are. It is highly configurable.\n\nThe `MinNameLength` config option takes an integer. It represents the minimum amount of characters the name must be. Its default is 1. The `AllowNamesEndingInNumbers` config option takes a boolean. When set to false, this cop will register offenses for names ending with numbers. Its default is false. The `AllowedNames` config option takes an array of permitted names that will never register an offense. The `ForbiddenNames` config option takes an array of restricted names that will always register an offense."
    },
    "Naming/ClassAndModuleCamelCase": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedNames": {
          "type": "array",
          "description": "Default: module_parent"
        }
      },
      "description": "Checks for class and module names with an underscore in them.\n\n`AllowedNames` config takes an array of permitted names. Its default value is `['module_parent']`. These names can be full class/module names or part of the name. eg. Adding `my_class` to the `AllowedNames` config will allow names like `my_class`, `my_class::User`, `App::my_class`, `App::my_class::User`, etc."
    },
    "Naming/ConstantName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks whether constant names are written using SCREAMING_SNAKE_CASE.\n\nTo avoid false positives, it ignores cases in which we cannot know for certain the type of value that would be assigned to a constant."
    },
    "Naming/FileName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: []"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "ExpectMatchingDefinition": {
          "type": "boolean",
          "description": "Default: false"
        },
        "CheckDefinitionPathHierarchy": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckDefinitionPathHierarchyRoots": {
          "type": "array",
          "description": "Default: lib, spec, test, src"
        },
        "Regex": {
          "description": "Default: <none>"
        },
        "IgnoreExecutableScripts": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedAcronyms": {
          "type": "array",
          "description": "Default: CLI, DSL, ACL, API, ASCII, CPU, CSS, DNS, EOF, GUID, HTML, HTTP, HTTPS, ID, IP, JSON, LHS, QPS, RAM, RHS, RPC, SLA, SMTP, SQL, SSH, TCP, TLS, TTL, UDP, UI, UID, UUID, URI, URL, UTF8, VM, XML, XMPP, XSRF, XSS"
        }
      },
      "description": "Makes sure that Ruby source files have snake_case names. Ruby scripts (i.e. source files with a shebang in the first line) are ignored.\n\nThe cop also ignores `.gemspec` files, because Bundler recommends using dashes to separate namespaces in nested gems (i.e. `bundler-console` becomes `Bundler::Console`). As such, the gemspec is supposed to be named `bundler-console.gemspec`.\n\nWhen `ExpectMatchingDefinition` (default: `false`) is `true`, the cop requires each file to have a class, module or `Struct` defined in it that matches the filename. This can be further configured using `CheckDefinitionPathHierarchy` (default: `true`) to determine whether the path should match the namespace of the above definition.\n\nWhen `IgnoreExecutableScripts` (default: `true`) is `true`, files that start with a shebang line are not considered by the cop.\n\nWhen `Regex` is set, the cop will flag any filename that does not match the regular expression."
    },
    "Naming/HeredocDelimiterCase": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "lowercase",
            "uppercase"
          ],
          "description": "Default: uppercase"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: lowercase, uppercase"
        }
      },
      "description": "Checks that your heredocs are using the configured case. By default it is configured to enforce uppercase heredocs."
    },
    "Naming/HeredocDelimiterNaming": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "ForbiddenDelimiters": {
          "type": "array",
          "description": "Default: (?i-mx:(^|\\s)(EO[A-Z]{1}|END)(\\s|$))"
        }
      },
      "description": "Checks that your heredocs are using meaningful delimiters. By default it disallows `END` and `EO*`, and can be configured through forbidden listing additional delimiters."
    },
    "Naming/InclusiveLanguage": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "CheckIdentifiers": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckConstants": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckVariables": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckStrings": {
          "type": "boolean",
          "description": "Default: false"
        },
        "CheckSymbols": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckComments": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckFilepaths": {
          "type": "boolean",
          "description": "Default: true"
        },
        "FlaggedTerms": {
          "description": "Default: {\"whitelist\"â‡’{\"Regex\"â‡’/white[-\\s]?list/, \"Suggestions\"â‡’[\"allowlist\", \"permit\"]}, \"blacklist\"â‡’{\"Regex\"â‡’/black[-\\s]?list/, \"Suggestions\"â‡’[\"denylist\", \"block\"]}, \"slave\"â‡’{\"WholeWord\"â‡’true, \"Suggestions\"â‡’[\"replica\", \"secondary\", \"follower\"]}}"
        }
      },
      "description": "Recommends the use of inclusive language instead of problematic terms. The cop can check the following locations for offenses:\n\n - identifiers\n\n - constants\n\n - variables\n\n - strings\n\n - symbols\n\n - comments\n\n - file paths\n\nEach of these locations can be individually enabled/disabled via configuration, for example CheckIdentifiers = true/false.\n\nFlagged terms are configurable for the cop. For each flagged term an optional Regex can be specified to identify offenses. Suggestions for replacing a flagged term can be configured and will be displayed as part of the offense message. An AllowedRegex can be specified for a flagged term to exempt allowed uses of the term. `WholeWord: true` can be set on a flagged term to indicate the cop should only match when a term matches the whole word (partial matches will not be offenses).\n\nThe cop supports autocorrection when there is only one suggestion. When there are multiple suggestions, the best suggestion cannot be identified and will not be autocorrected."
    },
    "Naming/MemoizedInstanceVariableName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyleForLeadingUnderscores": {
          "enum": [
            "disallowed",
            "required",
            "optional"
          ],
          "description": "Default: disallowed"
        },
        "SupportedStylesForLeadingUnderscores": {
          "type": "array",
          "description": "Default: disallowed, required, optional"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for memoized methods whose instance variable name does not match the method name. Applies to both regular methods (defined with `def`) and dynamic methods (defined with `define_method` or `define_singleton_method`).\n\nThis cop can be configured with the EnforcedStyleForLeadingUnderscores directive. It can be configured to allow for memoized instance variables prefixed with an underscore. Prefixing ivars with an underscore is a convention that is used to implicitly indicate that an ivar should not be set or referenced outside of the memoization method."
    },
    "Naming/MethodName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "snake_case",
            "camelCase"
          ],
          "description": "Default: snake_case"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: snake_case, camelCase"
        }
      },
      "description": "Makes sure that all methods use the configured style, snake_case or camelCase, for their names.\n\nThis cop has `AllowedPatterns` configuration option.\n\n  Naming/MethodName:\n    AllowedPatterns:\n      - '\\AonSelectionBulkChange\\z'\n      - '\\AonSelectionCleared\\z'\n\nMethod names matching patterns are always allowed."
    },
    "Naming/MethodParameterName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MinNameLength": {
          "type": "integer",
          "description": "Default: 3"
        },
        "AllowNamesEndingInNumbers": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedNames": {
          "type": "array",
          "description": "Default: as, at, by, cc, db, id, if, in, io, ip, of, on, os, pp, to"
        },
        "ForbiddenNames": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks method parameter names for how descriptive they are. It is highly configurable.\n\nThe `MinNameLength` config option takes an integer. It represents the minimum amount of characters the name must be. Its default is 3. The `AllowNamesEndingInNumbers` config option takes a boolean. When set to false, this cop will register offenses for names ending with numbers. Its default is false. The `AllowedNames` config option takes an array of permitted names that will never register an offense. The `ForbiddenNames` config option takes an array of restricted names that will always register an offense."
    },
    "Naming/PredicateName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: spec/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "NamePrefix": {
          "type": "array",
          "description": "Default: is_, has_, have_"
        },
        "ForbiddenPrefixes": {
          "type": "array",
          "description": "Default: is_, has_, have_"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: is_a?"
        },
        "MethodDefinitionMacros": {
          "type": "array",
          "description": "Default: define_method, define_singleton_method"
        }
      },
      "description": "Checks that predicate methods names end with a question mark and do not start with a forbidden prefix.\n\nA method is determined to be a predicate method if its name starts with one of the prefixes defined in the `NamePrefix` configuration. You can change what prefixes are considered by changing this option. Any method name that starts with one of these prefixes is required by the cop to end with a `?`. Other methods can be allowed by adding to the `AllowedMethods` configuration.\n\nThe `is_a?` method is allowed by default.\n\nIf `ForbiddenPrefixes` is set, methods that start with the configured prefixes will not be allowed and will be removed by autocorrection.\n\nIn other words, if `ForbiddenPrefixes` is empty, a method named `is_foo` will register an offense only due to the lack of question mark (and will be autocorrected to `is_foo?`). If `ForbiddenPrefixes` contains `is_`, `is_foo` will register an offense both because the ? is missing and because of the `is_` prefix, and will be corrected to `foo?`.\n\n`ForbiddenPrefixes` is only applied to prefixes in `NamePrefix`; a prefix in the former but not the latter will not be considered by this cop."
    },
    "Naming/RescuedExceptionsVariableName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "PreferredName": {
          "type": "string",
          "description": "Default: e"
        }
      },
      "description": "Makes sure that rescued exceptions variables are named as expected.\n\nThe `PreferredName` config option takes a `String`. It represents the required name of the variable. Its default is `e`.\n\nThis cop does not consider nested rescues because it cannot guarantee that the variable from the outer rescue is not used within the inner rescue (in which case, changing the inner variable would shadow the outer variable)."
    },
    "Naming/VariableName": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "snake_case",
            "camelCase"
          ],
          "description": "Default: snake_case"
        },
        "AllowedIdentifiers": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: snake_case, camelCase"
        }
      },
      "description": "Makes sure that all variables use the configured style, snake_case or camelCase, for their names."
    },
    "Naming/VariableNumber": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "snake_case",
            "normalcase",
            "non_integer"
          ],
          "description": "Default: normalcase"
        },
        "CheckMethodNames": {
          "type": "boolean",
          "description": "Default: true"
        },
        "CheckSymbols": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedIdentifiers": {
          "type": "array",
          "description": "Default: capture3, iso8601, rfc1123_date, rfc822, rfc2822, rfc3339, x86_64"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: snake_case, normalcase, non_integer"
        }
      },
      "description": "Makes sure that all numbered variables use the configured style, snake_case, normalcase, or non_integer, for their numbering.\n\nAdditionally, `CheckMethodNames` and `CheckSymbols` configuration options can be used to specify whether method names and symbols should be checked. Both are enabled by default."
    },
    "Security": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Security' department"
    },
    "Security/CompoundHash": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for implementations of the `hash` method which combine values using custom logic instead of delegating to `Array#hash`.\n\nManually combining hashes is error prone and hard to follow, especially when there are many values. Poor implementations may also introduce performance or security concerns if they are prone to collisions. Delegating to `Array#hash` is clearer and safer, although it might be slower depending on the use case."
    },
    "Security/Eval": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of `Kernel#eval` and `Binding#eval`."
    },
    "Security/IoMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the first argument to `IO.read`, `IO.binread`, `IO.write`, `IO.binwrite`, `IO.foreach`, and `IO.readlines`.\n\nIf argument starts with a pipe character (`'|'`) and the receiver is the `IO` class, a subprocess is created in the same way as `Kernel#open`, and its output is returned. `Kernel#open` may allow unintentional command injection, which is the reason these `IO` methods are a security risk. Consider to use `File.read` to disable the behavior of subprocess invocation."
    },
    "Security/JSONLoad": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://ruby-doc.org/stdlib-2.7.0/libdoc/json/rdoc/JSON.html#method-i-load"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the use of JSON class methods which have potential security issues."
    },
    "Security/MarshalLoad": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://ruby-doc.org/core-2.7.0/Marshal.html#module-Marshal-label-Security+considerations"
        }
      },
      "description": "Checks for the use of Marshal class methods which have potential security issues leading to remote code execution when loading from an untrusted source."
    },
    "Security/Open": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the use of `Kernel#open` and `URI.open` with dynamic data.\n\n`Kernel#open` and `URI.open` enable not only file access but also process invocation by prefixing a pipe symbol (e.g., `open(\"| ls\")`). So, it may lead to a serious security risk by using variable input to the argument of `Kernel#open` and `URI.open`. It would be better to use `File.open`, `IO.popen` or `URI.parse#open` explicitly.\n\n`open` and `URI.open` with literal strings are not flagged by this cop."
    },
    "Security/YAMLLoad": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://ruby-doc.org/stdlib-2.7.0/libdoc/yaml/rdoc/YAML.html#module-YAML-label-Security"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the use of YAML class methods which have potential security issues leading to remote code execution when loading from an untrusted source.\n\nRuby 3.1+ (Psych 4) uses `Psych.load` as `Psych.safe_load` by default."
    },
    "Style": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "'Style' department"
    },
    "Style/AccessModifierDeclarations": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "inline",
            "group"
          ],
          "description": "Default: group"
        },
        "AllowModifiersOnSymbols": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: inline, group"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Access modifiers should be declared to apply to a group of methods or inline before each method, depending on configuration. EnforcedStyle config covers only method definitions. Applications of visibility methods to symbols can be controlled using AllowModifiersOnSymbols config."
    },
    "Style/AccessorGrouping": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "separated",
            "grouped"
          ],
          "description": "Default: grouped"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: separated, grouped"
        }
      },
      "description": "Checks for grouping of accessors in `class` and `module` bodies. By default it enforces accessors to be placed in grouped declarations, but it can be configured to enforce separating them in multiple declarations.\n\nIf there is a method call before the accessor method it is always allowed as it might be intended like Sorbet."
    },
    "Style/Alias": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "prefer_alias",
            "prefer_alias_method"
          ],
          "description": "Default: prefer_alias"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: prefer_alias, prefer_alias_method"
        }
      },
      "description": "Enforces the use of either `#alias` or `#alias_method` depending on configuration. It also flags uses of `alias :symbol` rather than `alias bareword`.\n\nHowever, it will always enforce `method_alias` when used `alias` in an instance method definition and in a singleton method definition. If used in a block, always enforce `alias_method` unless it is an `instance_eval` block."
    },
    "Style/AndOr": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "always",
            "conditionals"
          ],
          "description": "Default: conditionals"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: always, conditionals"
        }
      },
      "description": "Checks for uses of `and` and `or`, and suggests using `&&` and `||` instead. It can be configured to check only in conditions or in all contexts."
    },
    "Style/ArgumentsForwarding": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowOnlyRestArgument": {
          "type": "boolean",
          "description": "Default: true"
        },
        "UseAnonymousForwarding": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "In Ruby 2.7, arguments forwarding has been added.\n\nThis cop identifies places where `do_something(*args, &block)` can be replaced by `do_something(...)`.\n\nIn Ruby 3.2, anonymous args/kwargs forwarding has been added.\n\nThis cop also identifies places where `use_args(*args)`/`use_kwargs(**kwargs)` can be replaced by `use_args(*)`/`use_kwargs(**)`; if desired, this functionality can be disabled by setting UseAnonymousForwarding: false."
    },
    "Style/ArrayCoercion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of `Array()` instead of explicit `Array` check or `[*var]`.\n\nThe cop is disabled by default due to safety concerns."
    },
    "Style/ArrayIntersect": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "In Ruby 3.1, `Array#intersect?` has been added.\n\nThis cop identifies places where `(array1 & array2).any?` can be replaced by `array1.intersect?(array2)`.\n\nThe `array1.intersect?(array2)` method is faster than `(array1 & array2).any?` and is more readable.\n\nIn cases like the following, compatibility is not ensured, so it will not be detected when using block argument.\n\n([1] & [1,2]).any? { |x| false }    # => false [1].intersect?([1,2]) { |x| false } # => true"
    },
    "Style/ArrayJoin": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of \"*\" as a substitute for _join_.\n\nNot all cases can reliably checked, due to Ruby's dynamic types, so we consider only cases when the first argument is an array literal or the second is a string literal."
    },
    "Style/AsciiComments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedChars": {
          "type": "array",
          "description": "Default: Â©"
        }
      },
      "description": "Checks for non-ascii (non-English) characters in comments. You could set an array of allowed non-ascii chars in `AllowedChars` attribute (copyright notice \"Â©\" by default)."
    },
    "Style/Attr": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of Module#attr."
    },
    "Style/AutoResourceCleanup": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for cases when you could use a block accepting version of a method that does automatic resource cleanup."
    },
    "Style/BarePercentLiterals": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "percent_q",
            "bare_percent"
          ],
          "description": "Default: bare_percent"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: percent_q, bare_percent"
        }
      },
      "description": "Checks if usage of %() or %Q() matches configuration."
    },
    "Style/BeginBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for BEGIN blocks."
    },
    "Style/BisectedAttrAccessor": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for places where `attr_reader` and `attr_writer` for the same method can be combined into single `attr_accessor`."
    },
    "Style/BlockComments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Looks for uses of block comments (=begin...=end)."
    },
    "Style/BlockDelimiters": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "line_count_based",
            "semantic",
            "braces_for_chaining",
            "always_braces"
          ],
          "description": "Default: line_count_based"
        },
        "ProceduralMethods": {
          "type": "array",
          "description": "Default: benchmark, bm, bmbm, create, each_with_object, measure, new, realtime, tap, with_object"
        },
        "FunctionalMethods": {
          "type": "array",
          "description": "Default: let, let!, subject, watch"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: lambda, proc, it"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowBracesOnProceduralOneLiners": {
          "type": "boolean",
          "description": "Default: false"
        },
        "BracesRequiredMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: line_count_based, semantic, braces_for_chaining, always_braces"
        }
      },
      "description": "Check for uses of braces or do/end around single line or multi-line blocks.\n\nMethods that can be either procedural or functional and cannot be categorised from their usage alone is ignored. `lambda`, `proc`, and `it` are their defaults. Additional methods can be added to the `AllowedMethods`."
    },
    "Style/CaseEquality": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowOnConstant": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowOnSelfClass": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "If `AllowOnSelfClass` option is enabled, the cop will ignore violations when the receiver of the case equality operator is `self.class`. Note intermediate variables are not accepted."
    },
    "Style/CaseLikeIf": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MinBranchesCount": {
          "type": "integer",
          "description": "Default: 3"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies places where `if-elsif` constructions can be replaced with `case-when`."
    },
    "Style/CharacterLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of the character literal ?x. Starting with Ruby 1.9 character literals are essentially one-character strings, so this syntax is mostly redundant at this point.\n\n? character literal can be used to express meta and control character. That's a good use case of ? literal so it doesn't count it as an offense."
    },
    "Style/ClassAndModuleChildren": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "nested",
            "compact"
          ],
          "description": "Default: nested"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: nested, compact"
        }
      },
      "description": "Checks the style of children definitions at classes and modules. Basically there are two different styles:\n\nThe compact style is only forced for classes/modules with one child."
    },
    "Style/ClassCheck": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "is_a?",
            "kind_of?"
          ],
          "description": "Default: is_a?"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: is_a?, kind_of?"
        }
      },
      "description": "Enforces consistent use of `Object#is_a?` or `Object#kind_of?`."
    },
    "Style/ClassEqualityComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: ==, equal?, eql?"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Enforces the use of `Object#instance_of?` instead of class comparison for equality. `==`, `equal?`, and `eql?` custom method definitions are allowed by default. These are customizable with `AllowedMethods` option."
    },
    "Style/ClassMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of the class/module name instead of self, when defining class/module methods."
    },
    "Style/ClassMethodsDefinitions": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "def_self",
            "self_class"
          ],
          "description": "Default: def_self"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: def_self, self_class"
        }
      },
      "description": "Enforces using `def self.method_name` or `class << self` to define class methods."
    },
    "Style/ClassVars": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for uses of class variables. Offenses are signaled only on assignment to class variables to reduce the number of offenses that would be reported.\n\nYou have to be careful when setting a value for a class variable; if a class has been inherited, changing the value of a class variable also affects the inheriting classes. This means that it's almost always better to use a class instance variable instead."
    },
    "Style/CollectionCompact": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedReceivers": {
          "type": "array",
          "description": "Default: []"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where custom logic on rejection nils from arrays and hashes can be replaced with `{Array,Hash}#{compact,compact!}`."
    },
    "Style/CollectionMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "PreferredMethods": {
          "description": "Default: {\"collect\"â‡’\"map\", \"collect!\"â‡’\"map!\", \"collect_concat\"â‡’\"flat_map\", \"inject\"â‡’\"reduce\", \"detect\"â‡’\"find\", \"find_all\"â‡’\"select\", \"member?\"â‡’\"include?\"}"
        },
        "MethodsAcceptingSymbol": {
          "type": "array",
          "description": "Default: inject, reduce"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of consistent method names from the Enumerable module.\n\nYou can customize the mapping from undesired method to desired method.\n\ne.g. to use `detect` over `find`:\n\n  Style/CollectionMethods:\n    PreferredMethods:\n      find: detect"
    },
    "Style/ColonMethodCall": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for methods invoked via the `::` operator instead of the `.` operator (like `FileUtils::rmdir` instead of `FileUtils.rmdir`)."
    },
    "Style/ColonMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for class methods that are defined using the `::` operator instead of the `.` operator."
    },
    "Style/CombinableLoops": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where multiple consecutive loops over the same data can be combined into a single loop. It is very likely that combining them will make the code more efficient and more concise."
    },
    "Style/CommandLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "backticks",
            "percent_x",
            "mixed"
          ],
          "description": "Default: backticks"
        },
        "AllowInnerBackticks": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: backticks, percent_x, mixed"
        }
      },
      "description": "Enforces using `` or %x around command literals."
    },
    "Style/CommentAnnotation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "Keywords": {
          "type": "array",
          "description": "Default: TODO, FIXME, OPTIMIZE, HACK, REVIEW, NOTE"
        },
        "RequireColon": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks that comment annotation keywords are written according to guidelines.\n\nAnnotation keywords can be specified by overriding the cop's `Keywords` configuration. Keywords are allowed to be single words or phrases.\n\nWith a multiline comment block (where each line is only a comment), only the first line will be able to register an offense, even if an annotation keyword starts another line. This is done to prevent incorrect registering of keywords (eg. `review`) inside a paragraph as an annotation."
    },
    "Style/CommentedKeyword": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for comments put on the same line as some keywords. These keywords are: `class`, `module`, `def`, `begin`, `end`.\n\nNote that some comments (`:nodoc:`, `:yields:`, `rubocop:disable` and `rubocop:todo`) are allowed.\n\nAutocorrection removes comments from `end` keyword and keeps comments for `class`, `module`, `def` and `begin` above the keyword."
    },
    "Style/ComparableClamp": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Enforces the use of `Comparable#clamp` instead of comparison by minimum and maximum.\n\nThis cop supports autocorrection for `if/elsif/else` bad style only. Because `ArgumentError` occurs if the minimum and maximum of `clamp` arguments are reversed. When these are variables, it is not possible to determine which is the minimum and maximum:\n\n[1, [2, 3].max].min # => 1 1.clamp(3, 1)       # => min argument must be smaller than max argument (ArgumentError)"
    },
    "Style/ConcatArrayLiterals": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of `Array#push(item)` instead of `Array#concat([item])` to avoid redundant array literals."
    },
    "Style/ConditionalAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "assign_to_condition",
            "assign_inside_condition"
          ],
          "description": "Default: assign_to_condition"
        },
        "SingleLineConditionsOnly": {
          "type": "boolean",
          "description": "Default: true"
        },
        "IncludeTernaryExpressions": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: assign_to_condition, assign_inside_condition"
        }
      },
      "description": "Check for `if` and `case` statements where each branch is used for assignment to the same variable when using the return of the condition can be used instead."
    },
    "Style/ConstantVisibility": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "IgnoreModules": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks that constants defined in classes and modules have an explicit visibility declaration. By default, Ruby makes all class- and module constants public, which litters the public API of the class or module. Explicitly declaring a visibility makes intent more clear, and prevents outside actors from touching private state."
    },
    "Style/Copyright": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "Notice": {
          "type": "string",
          "description": "Default: ^Copyright (\\(c\\) )?2[0-9]{3} .+"
        },
        "AutocorrectNotice": {
          "type": "string",
          "description": "Default: ``"
        }
      },
      "description": "Check that a copyright notice was given in each source file.\n\nThe default regexp for an acceptable copyright notice can be found in config/default.yml. The default can be changed as follows:\n\nStyle/Copyright:   Notice: '^Copyright (\\(c\\) )?2\\d{3} Acme Inc'\n\nThis regex string is treated as an unanchored regex. For each file that RuboCop scans, a comment that matches this regex must be found or an offense is reported."
    },
    "Style/DataInheritance": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for inheritance from `Data.define` to avoid creating the anonymous parent class."
    },
    "Style/DateTime": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowCoercion": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for consistent usage of the `DateTime` class over the `Time` class. This cop is disabled by default since these classes, although highly overlapping, have particularities that make them not replaceable in certain situations when dealing with multiple timezones and/or DST."
    },
    "Style/DefWithParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for parentheses in the definition of a method, that does not take any arguments. Both instance and class/singleton methods are checked."
    },
    "Style/Dir": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for places where the `#\\_\\_dir\\_\\_` method can replace more complex constructs to retrieve a canonicalized absolute path to the current file."
    },
    "Style/DirEmpty": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Prefer to use `Dir.empty?('path/to/dir')` when checking if a directory is empty."
    },
    "Style/DisableCopsWithinSourceCodeDirective": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowedCops": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Detects comments to enable/disable RuboCop. This is useful if want to make sure that every RuboCop error gets fixed and not quickly disabled with a comment.\n\nSpecific cops can be allowed with the `AllowedCops` configuration. Note that if this configuration is set, `rubocop:disable all` is still disallowed."
    },
    "Style/DocumentDynamicEvalDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "When using `class_eval` (or other `eval`) with string interpolation, add a comment block showing its appearance if interpolated (a practice used in Rails code)."
    },
    "Style/Documentation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: spec/**/*, test/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedConstants": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for missing top-level documentation of classes and modules. Classes with no body are exempt from the check and so are namespace modules - modules that have nothing in their bodies except classes, other modules, constant definitions or constant visibility declarations.\n\nThe documentation requirement is annulled if the class or module has a `#:nodoc:` comment next to it. Likewise, `#:nodoc: all` does the same for all its children."
    },
    "Style/DocumentationMethod": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: spec/**/*, test/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "RequireForNonPublicMethods": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for missing documentation comment for public methods. It can optionally be configured to also require documentation for non-public methods.\n\nThis cop allows `initialize` method because `initialize` is a special method called from `new`. In some programming languages they are called constructor to distinguish it from method."
    },
    "Style/DoubleCopDisableDirective": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Detects double disable comments on one line. This is mostly to catch automatically generated comments that need to be regenerated."
    },
    "Style/DoubleNegation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "allowed_in_returns",
            "forbidden"
          ],
          "description": "Default: allowed_in_returns"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: allowed_in_returns, forbidden"
        }
      },
      "description": "Checks for uses of double negation (`!!`) to convert something to a boolean value.\n\nWhen using `EnforcedStyle: allowed_in_returns`, allow double negation in contexts that use boolean as a return value. When using `EnforcedStyle: forbidden`, double negation should be forbidden always.\n\nwhen `something` is a boolean value `!!something` and `!something.nil?` are not the same thing. As you're unlikely to write code that can accept values of any type this is rarely a problem in practice."
    },
    "Style/EachForSimpleLoop": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for loops which iterate a constant number of times, using a Range literal and `#each`. This can be done more readably using `Integer#times`.\n\nThis check only applies if the block takes no parameters."
    },
    "Style/EachWithObject": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Looks for inject / reduce calls where the passed in object is returned at the end and so could be replaced by each_with_object without the need to return the object at the end.\n\nHowever, we can't replace with each_with_object if the accumulator parameter is assigned to within the block."
    },
    "Style/EmptyBlockParameter": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for pipes for empty block parameters. Pipes for empty block parameters do not cause syntax errors, but they are redundant."
    },
    "Style/EmptyCaseCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for case statements with an empty condition."
    },
    "Style/EmptyElse": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "empty",
            "nil",
            "both"
          ],
          "description": "Default: both"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: empty, nil, both"
        }
      },
      "description": "Checks for empty else-clauses, possibly including comments and/or an explicit `nil` depending on the EnforcedStyle."
    },
    "Style/EmptyHeredoc": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for using empty heredoc to reduce redundancy."
    },
    "Style/EmptyLambdaParameter": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for parentheses for empty lambda parameters. Parentheses for empty lambda parameters do not cause syntax errors, but they are redundant."
    },
    "Style/EmptyLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for the use of a method, the result of which would be a literal, like an empty array, hash, or string."
    },
    "Style/EmptyMethod": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "compact",
            "expanded"
          ],
          "description": "Default: compact"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: compact, expanded"
        }
      },
      "description": "Checks for the formatting of empty method definitions. By default it enforces empty method definitions to go on a single line (compact style), but it can be configured to enforce the `end` to go on its own line (expanded style).\n\nA method definition is not considered empty if it contains comments.\n\nAutocorrection will not be applied for the `compact` style if the resulting code is longer than the `Max` configuration for `Layout/LineLength`, but an offense will still be registered."
    },
    "Style/Encoding": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks ensures source files have no utf-8 encoding comments."
    },
    "Style/EndBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for END blocks."
    },
    "Style/EndlessMethod": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "allow_single_line",
            "allow_always",
            "disallow"
          ],
          "description": "Default: allow_single_line"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: allow_single_line, allow_always, disallow"
        }
      },
      "description": "Checks for endless methods.\n\nIt can enforce either the use of endless methods definitions for single-lined method bodies, or disallow endless methods.\n\nOther method definition types are not considered by this cop.\n\nThe supported styles are:\n\n - allow_single_line (default) - only single line endless method definitions are allowed.\n\n - allow_always - all endless method definitions are allowed.\n\n - disallow - all endless method definitions are disallowed.\n\nIncorrect endless method definitions will always be corrected to a multi-line definition."
    },
    "Style/EnvHome": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for consistent usage of `ENV['HOME']`. If `nil` is used as the second argument of `ENV.fetch`, it is treated as a bad case like `ENV[]`."
    },
    "Style/EvalWithLocation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Ensures that eval methods (`eval`, `instance_eval`, `class_eval` and `module_eval`) are given filename and line number values (`\\_\\_FILE\\_\\_` and `\\_\\_LINE\\_\\_`). This data is used to ensure that any errors raised within the evaluated code will be given the correct identification in a backtrace.\n\nThe cop also checks that the line number given relative to `\\_\\_LINE\\_\\_` is correct.\n\nThis cop will autocorrect incorrect or missing filename and line number values. However, if `eval` is called without a binding argument, the cop will not attempt to automatically add a binding, or add filename and line values.\n\nThis cop works only when a string literal is given as a code string. No offense is reported if a string variable is given as below:"
    },
    "Style/EvenOdd": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for places where `Integer#even?` or `Integer#odd?` can be used."
    },
    "Style/ExactRegexpMatch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for exact regexp match inside Regexp literals."
    },
    "Style/ExpandPathArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for use of the `File.expand_path` arguments. Likewise, it also checks for the `Pathname.new` argument.\n\nContrastive bad case and good case are alternately shown in the following examples."
    },
    "Style/ExplicitBlockArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Enforces the use of explicit block argument to avoid writing block literal that just passes its arguments to another block.\n\nThis cop only registers an offense if the block args match the yield args exactly."
    },
    "Style/ExponentialNotation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "scientific",
            "engineering",
            "integral"
          ],
          "description": "Default: scientific"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: scientific, engineering, integral"
        }
      },
      "description": "Enforces consistency when using exponential notation for numbers in the code (eg 1.2e4). Different styles are supported:\n\n - scientific which enforces a mantissa between 1 (inclusive) and 10 (exclusive).\n\n - engineering which enforces the exponent to be a multiple of 3 and the mantissa to be between 0.1 (inclusive) and 10 (exclusive).\n\n - integral which enforces the mantissa to always be a whole number without trailing zeroes."
    },
    "Style/FetchEnvVar": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowedVars": {
          "type": "array",
          "description": "Default: []"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://rubystyle.guide/#hash-fetch-defaults"
        }
      },
      "description": "Suggests `ENV.fetch` for the replacement of `ENV[]`. `ENV[]` silently fails and returns `nil` when the environment variable is unset, which may cause unexpected behaviors when the developer forgets to set it. On the other hand, `ENV.fetch` raises KeyError or returns the explicitly specified default value."
    },
    "Style/FileEmpty": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Prefer to use `File.empty?('path/to/file')` when checking if a file is empty."
    },
    "Style/FileRead": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Favor `File.(bin)read` convenience methods."
    },
    "Style/FileWrite": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Favor `File.(bin)write` convenience methods.\n\nThere are different method signatures between `File.write` (class method) and `File#write` (instance method). The following case will be allowed because static analysis does not know the contents of the splat argument:\n\nFile.open(filename, 'w') do |f|   f.write(*objects) end"
    },
    "Style/FloatDivision": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "left_coerce",
            "right_coerce",
            "single_coerce",
            "fdiv"
          ],
          "description": "Default: single_coerce"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://blog.rubystyle.guide/ruby/2019/06/21/float-division.html"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: left_coerce, right_coerce, single_coerce, fdiv"
        }
      },
      "description": "Checks for division with integers coerced to floats. It is recommended to either always use `fdiv` or coerce one side only. This cop also provides other options for code consistency."
    },
    "Style/For": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "each",
            "for"
          ],
          "description": "Default: each"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: each, for"
        }
      },
      "description": "Looks for uses of the `for` keyword or `each` method. The preferred alternative is set in the EnforcedStyle configuration parameter. An `each` call with a block on a single line is always allowed."
    },
    "Style/FormatString": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "format",
            "sprintf",
            "percent"
          ],
          "description": "Default: format"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: format, sprintf, percent"
        }
      },
      "description": "Enforces the use of a single string formatting utility. Valid options include Kernel#format, Kernel#sprintf and String#%.\n\nThe detection of String#% cannot be implemented in a reliable manner for all cases, so only two scenarios are considered - if the first argument is a string literal and if the second argument is an array literal."
    },
    "Style/FormatStringToken": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "annotated",
            "template",
            "unannotated"
          ],
          "description": "Default: annotated"
        },
        "MaxUnannotatedPlaceholdersAllowed": {
          "type": "integer",
          "description": "Default: 1"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: annotated, template, unannotated"
        }
      },
      "description": "Use a consistent style for named format string tokens.\n\n`unannotated` style cop only works for strings which are passed as arguments to those methods: `printf`, `sprintf`, `format`, `%`. The reason is that _unannotated_ format is very similar to encoded URLs or Date/Time formatting strings.\n\nThis cop can be customized allowed methods with `AllowedMethods`. By default, there are no methods to allowed.\n\nIt is allowed to contain unannotated token if the number of them is less than or equals to `MaxUnannotatedPlaceholdersAllowed`."
    },
    "Style/FrozenStringLiteralComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "always",
            "always_true",
            "never"
          ],
          "description": "Default: always"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: always, always_true, never"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Helps you transition from mutable string literals to frozen string literals. It will add the `# frozen_string_literal: true` magic comment to the top of files to enable frozen string literals. Frozen string literals may be default in future Ruby. The comment will be added below a shebang and encoding comment. The frozen string literal comment is only valid in Ruby 2.3+.\n\nNote that the cop will accept files where the comment exists but is set to `false` instead of `true`.\n\nTo require a blank line after this comment, please see `Layout/EmptyLineAfterMagicComment` cop."
    },
    "Style/GlobalStdStream": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of `$stdout/$stderr/$stdin` instead of `STDOUT/STDERR/STDIN`. `STDOUT/STDERR/STDIN` are constants, and while you can actually reassign (possibly to redirect some stream) constants in Ruby, you'll get an interpreter warning if you do so."
    },
    "Style/GlobalVars": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedVariables": {
          "type": "array",
          "description": "Default: []"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://www.zenspider.com/ruby/quickref.html"
        }
      },
      "description": "Looks for uses of global variables. It does not report offenses for built-in global variables. Built-in global variables are allowed by default. Additionally users can allow additional variables via the AllowedVariables option.\n\nNote that backreferences like $1, $2, etc are not global variables."
    },
    "Style/GuardClause": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "MinBodyLength": {
          "type": "integer",
          "description": "Default: 1"
        },
        "AllowConsecutiveConditionals": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Use a guard clause instead of wrapping the code inside a conditional expression\n\nA condition with an `elsif` or `else` branch is allowed unless one of `return`, `break`, `next`, `raise`, or `fail` is used in the body of the conditional expression.\n\nAutocorrect works in most cases except with if-else statements   that contain logical operators such as `foo || raise('exception')`"
    },
    "Style/HashAsLastArrayItem": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "braces",
            "no_braces"
          ],
          "description": "Default: braces"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: braces, no_braces"
        }
      },
      "description": "Checks for presence or absence of braces around hash literal as a last array item depending on configuration.\n\nThis cop will ignore arrays where all items are hashes, regardless of EnforcedStyle."
    },
    "Style/HashConversion": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowSplatArgument": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks the usage of pre-2.1 `Hash[args]` method of converting enumerables and sequences of values to hashes.\n\nCorrection code from splat argument (`Hash[*ary]`) is not simply determined. For example, `Hash[*ary]` can be replaced with `ary.each_slice(2).to_h` but it will be complicated. So, `AllowSplatArgument` option is true by default to allow splat argument for simple code."
    },
    "Style/HashEachMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedReceivers": {
          "type": "array",
          "description": "Default: Thread.current"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for uses of `each_key` and `each_value` Hash methods.\n\nIf you have an array of two-element arrays, you can put   parentheses around the block arguments to indicate that you're not   working with a hash, and suppress RuboCop offenses."
    },
    "Style/HashExcept": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for usages of `Hash#reject`, `Hash#select`, and `Hash#filter` methods that can be replaced with `Hash#except` method.\n\nThis cop should only be enabled on Ruby version 3.0 or higher. (`Hash#except` was added in Ruby 3.0.)\n\nFor safe detection, it is limited to commonly used string and symbol comparisons when used `==`. And do not check `Hash#delete_if` and `Hash#keep_if` to change receiver object."
    },
    "Style/HashLikeCase": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "MinBranchesCount": {
          "type": "integer",
          "description": "Default: 3"
        }
      },
      "description": "Checks for places where `case-when` represents a simple 1:1 mapping and can be replaced with a hash lookup."
    },
    "Style/HashSyntax": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "ruby19",
            "hash_rockets",
            "no_mixed_keys",
            "ruby19_no_mixed_keys"
          ],
          "description": "Default: ruby19"
        },
        "EnforcedShorthandSyntax": {
          "enum": [
            "always",
            "never",
            "either",
            "consistent"
          ],
          "description": "Default: always"
        },
        "UseHashRocketsWithSymbolValues": {
          "type": "boolean",
          "description": "Default: false"
        },
        "PreferHashRocketsForNonAlnumEndingSymbols": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: ruby19, hash_rockets, no_mixed_keys, ruby19_no_mixed_keys"
        },
        "SupportedShorthandSyntax": {
          "type": "array",
          "description": "Default: always, never, either, consistent"
        }
      },
      "description": "Checks hash literal syntax.\n\nIt can enforce either the use of the class hash rocket syntax or the use of the newer Ruby 1.9 syntax (when applicable).\n\nA separate offense is registered for each problematic pair.\n\nThe supported styles are:\n\n - ruby19 - forces use of the 1.9 syntax (e.g. {a: 1}) when hashes have all symbols for keys\n\n - hash_rockets - forces use of hash rockets for all hashes\n\n - no_mixed_keys - simply checks for hashes with mixed syntaxes\n\n - ruby19_no_mixed_keys - forces use of ruby 1.9 syntax and forbids mixed syntax hashes\n\nThis cop has `EnforcedShorthandSyntax` option. It can enforce either the use of the explicit hash value syntax or the use of Ruby 3.1's hash value shorthand syntax.\n\nThe supported styles are:\n\n - always - forces use of the 3.1 syntax (e.g. {foo:})\n\n - never - forces use of explicit hash literal value\n\n - either - accepts both shorthand and explicit use of hash literal value\n\n - consistent - forces use of the 3.1 syntax only if all values can be omitted in the hash"
    },
    "Style/HashTransformKeys": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for uses of `\\_.each_with_object({}) {...}`, `\\_.map {...}.to_h`, and `Hash[\\_.map {...}]` that are actually just transforming the keys of a hash, and tries to use a simpler & faster call to `transform_keys` instead. It should only be enabled on Ruby version 2.5 or newer. (`transform_keys` was added in Ruby 2.5.)"
    },
    "Style/HashTransformValues": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for uses of `\\_.each_with_object({}) {...}`, `\\_.map {...}.to_h`, and `Hash[\\_.map {...}]` that are actually just transforming the values of a hash, and tries to use a simpler & faster call to `transform_values` instead."
    },
    "Style/IdenticalConditionalBranches": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for identical expressions at the beginning or end of each branch of a conditional expression. Such expressions should normally be placed outside the conditional expression - before or after it.\n\nThe cop is poorly named and some people might think that it actually checks for duplicated conditional branches. The name will probably be changed in a future major RuboCop release."
    },
    "Style/IfInsideElse": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowIfModifier": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "If the `else` branch of a conditional consists solely of an `if` node, it can be combined with the `else` to become an `elsif`. This helps to keep the nesting level from getting too deep."
    },
    "Style/IfUnlessModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for `if` and `unless` statements that would fit on one line if written as modifier `if`/`unless`. The cop also checks for modifier `if`/`unless` lines that exceed the maximum line length.\n\nThe maximum line length is configured in the `Layout/LineLength` cop. The tab size is configured in the `IndentationWidth` of the `Layout/IndentationStyle` cop.\n\nOne-line pattern matching is always allowed. To ensure that there are few cases where the match variable is not used, and to prevent oversights. The variable `x` becomes undefined and raises `NameError` when the following example is changed to the modifier form:\n\nif [42] in [x]   x # `x` is undefined when using modifier form. end\n\nIt is allowed when `defined?` argument has an undefined value, because using the modifier form causes the following incompatibility:\n\nunless defined?(undefined_foo)   undefined_foo = 'default_value' end undefined_foo # => 'default_value'  undefined_bar = 'default_value' unless defined?(undefined_bar) undefined_bar # => nil"
    },
    "Style/IfUnlessModifierOfIfUnless": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for if and unless statements used as modifiers of other if or unless statements."
    },
    "Style/IfWithBooleanLiteralBranches": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: nonzero?"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for redundant `if` with boolean literal branches. It checks only conditions to return boolean value (`true` or `false`) for safe detection. The conditions to be checked are comparison methods, predicate methods, and double negation (!!). `nonzero?` method is allowed by default. These are customizable with `AllowedMethods` option.\n\nThis cop targets only `if`s with a single `elsif` or `else` branch. The following code will be allowed, because it has two `elsif` branches:\n\nif foo   true elsif bar > baz   true elsif qux > quux # Single `elsif` is warned, but two or more `elsif`s are not.   true else   false end"
    },
    "Style/IfWithSemicolon": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of semicolon in if statements."
    },
    "Style/ImplicitRuntimeError": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for `raise` or `fail` statements which do not specify an explicit exception class. (This raises a `RuntimeError`. Some projects might prefer to use exception classes which more precisely identify the nature of the error.)"
    },
    "Style/InPatternThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for `in;` uses in `case` expressions."
    },
    "Style/InfiniteLoop": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Use `Kernel#loop` for infinite loops."
    },
    "Style/InlineComment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for trailing inline comments."
    },
    "Style/InverseMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "InverseMethods": {
          "description": "Default: {:any?â‡’:none?, :even?â‡’:odd?, :==â‡’:!=, :=â‡’:!, :<â‡’:>=, :>â‡’:â‡}"
        },
        "InverseBlocks": {
          "description": "Default: {:selectâ‡’:reject, :select!â‡’:reject!}"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Check for usages of not (`not` or `!`) called on a method when an inverse of that method can be used instead.\n\nMethods that can be inverted by a not (`not` or `!`) should be defined in `InverseMethods`.\n\nMethods that are inverted by inverting the return of the block that is passed to the method should be defined in `InverseBlocks`."
    },
    "Style/InvertibleUnlessCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "InverseMethods": {
          "description": "Default: {:!=â‡’:==, :>â‡’:â‡, :â‡â‡’:>, :<â‡’:>=, :>=â‡’:<, :!â‡’:=, :zero?â‡’:nonzero?, :nonzero?â‡’:zero?, :any?â‡’:none?, :none?â‡’:any?, :even?â‡’:odd?, :odd?â‡’:even?}"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for usages of `unless` which can be replaced by `if` with inverted condition. Code without `unless` is easier to read, but that is subjective, so this cop is disabled by default.\n\nMethods that can be inverted should be defined in `InverseMethods`. Note that the relationship of inverse methods needs to be defined in both directions. For example,\n\nInverseMethods:   :!=: :==   :even?: :odd?   :odd?: :even?\n\nwill suggest both `even?` and `odd?` to be inverted, but only `!=` (and not `==`)."
    },
    "Style/IpAddresses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: **/*.gemfile, **/Gemfile, **/gems.rb, **/*.gemspec"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedAddresses": {
          "type": "array",
          "description": "Default: ::"
        }
      },
      "description": "Checks for hardcoded IP addresses, which can make code brittle. IP addresses are likely to need to be changed when code is deployed to a different server or environment, which may break a deployment if forgotten. Prefer setting IP addresses in ENV or other configuration."
    },
    "Style/KeywordParametersOrder": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Enforces that optional keyword parameters are placed at the end of the parameters list.\n\nThis improves readability, because when looking through the source, it is expected to find required parameters at the beginning of parameters list and optional parameters at the end."
    },
    "Style/Lambda": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "line_count_dependent",
            "lambda",
            "literal"
          ],
          "description": "Default: line_count_dependent"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: line_count_dependent, lambda, literal"
        }
      },
      "description": "(by default) checks for uses of the lambda literal syntax for single line lambdas, and the method call syntax for multiline lambdas. It is configurable to enforce one of the styles for both single line and multiline lambdas as well."
    },
    "Style/LambdaCall": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "call",
            "braces"
          ],
          "description": "Default: call"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: call, braces"
        }
      },
      "description": "Checks for use of the lambda.(args) syntax."
    },
    "Style/LineEndConcatenation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for string literal concatenation at the end of a line."
    },
    "Style/MagicCommentFormat": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "snake_case",
            "kebab_case"
          ],
          "description": "Default: snake_case"
        },
        "DirectiveCapitalization": {
          "type": "string",
          "description": "Default: lowercase"
        },
        "ValueCapitalization": {
          "description": "Default: <none>"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: snake_case, kebab_case"
        },
        "SupportedCapitalizations": {
          "type": "array",
          "description": "Default: lowercase, uppercase"
        }
      },
      "description": "Ensures magic comments are written consistently throughout your code base. Looks for discrepancies in separators (`-` vs `_`) and capitalization for both magic comment directives and values.\n\nRequired capitalization can be set with the `DirectiveCapitalization` and `ValueCapitalization` configuration keys.\n\nIf one of these configuration is set to nil, any capitalization is allowed."
    },
    "Style/MapCompactWithConditionalBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Prefer `select` or `reject` over `map { ... }.compact`."
    },
    "Style/MapToHash": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for uses of `map.to_h` or `collect.to_h` that could be written with just `to_h` in Ruby >= 2.6.\n\n`Style/HashTransformKeys` and `Style/HashTransformValues` will also change this pattern if only hash keys or hash values are being transformed."
    },
    "Style/MapToSet": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for uses of `map.to_set` or `collect.to_set` that could be written with just `to_set`."
    },
    "Style/MethodCallWithArgsParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "IgnoreMacros": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "IncludedMacros": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowParenthesesInMultilineCall": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowParenthesesInChaining": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowParenthesesInCamelCaseMethod": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowParenthesesInStringInterpolation": {
          "type": "boolean",
          "description": "Default: false"
        },
        "EnforcedStyle": {
          "enum": [
            "require_parentheses",
            "omit_parentheses"
          ],
          "description": "Default: require_parentheses"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: require_parentheses, omit_parentheses"
        }
      },
      "description": "Enforces the presence (default) or absence of parentheses in method calls containing parameters.\n\nIn the default style (require_parentheses), macro methods are allowed. Additional methods can be added to the `AllowedMethods` or `AllowedPatterns` list. These options are valid only in the default style. Macros can be included by either setting `IgnoreMacros` to false or adding specific macros to the `IncludedMacros` list.\n\nPrecedence of options is as follows:\n\n  1. AllowedMethods\n\n  2. AllowedPatterns\n\n  3. IncludedMacros\n\nIf a method is listed in both `IncludedMacros` and `AllowedMethods`, then the latter takes precedence (that is, the method is allowed).\n\nIn the alternative style (omit_parentheses), there are three additional options.\n\n  1. AllowParenthesesInChaining is false by default. Setting it to true allows the presence of parentheses in the last call during method chaining.\n\n  2. AllowParenthesesInMultilineCall is false by default. Setting it to true allows the presence of parentheses in multi-line method calls.\n\n  3. AllowParenthesesInCamelCaseMethod is false by default. This allows the presence of parentheses when calling a method whose name begins with a capital letter and which has no arguments. Setting it to true allows the presence of parentheses in such a method call even with arguments.\n\nThe style of `omit_parentheses` allows parentheses in cases where omitting them results in ambiguous or syntactically incorrect code.\n\nNon-exhaustive list of examples:\n\n - Parentheses are required allowed in method calls with arguments inside literals, logical operators, setting default values in position and keyword arguments, chaining and more.\n\n - Parentheses are allowed in method calls with arguments inside operators to avoid ambiguity. triple-dot syntax introduced in Ruby 2.7 as omitting them starts an endless range.\n\n - Parentheses are allowed when forwarding arguments with the triple-dot syntax introduced in Ruby 2.7 as omitting them starts an endless range.\n\n - Parentheses are required in calls with arguments when inside an endless method definition introduced in Ruby 3.0.\n\n - Ruby 3.1â€™s hash omission syntax allows parentheses if the method call is in conditionals and requires parentheses if the call is not the value-returning expression. See https://bugs.ruby-lang.org/issues/18396.\n\n - Parentheses are required in anonymous arguments, keyword arguments and block passing in Ruby 3.2."
    },
    "Style/MethodCallWithoutArgsParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for unwanted parentheses in parameterless method calls.\n\nThis cop can be customized allowed methods with `AllowedMethods`. By default, there are no methods to allowed."
    },
    "Style/MethodCalledOnDoEndBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for methods called on a do...end block. The point of this check is that it's easy to miss the call tacked on to the block when reading code."
    },
    "Style/MethodDefParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "require_parentheses",
            "require_no_parentheses",
            "require_no_parentheses_except_multiline"
          ],
          "description": "Default: require_parentheses"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: require_parentheses, require_no_parentheses, require_no_parentheses_except_multiline"
        }
      },
      "description": "Checks for parentheses around the arguments in method definitions. Both instance and class/singleton methods are checked.\n\nRegardless of style, parentheses are necessary for:\n\n  1. Endless methods\n\n  2. Argument lists containing a forward-arg (â€¦â€‹)\n\n  3. Argument lists containing an anonymous rest arguments forwarding (*)\n\n  4. Argument lists containing an anonymous keyword rest arguments forwarding (**)\n\n  5. Argument lists containing an anonymous block forwarding (&)\n\nRemoving the parens would be a syntax error here."
    },
    "Style/MinMax": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for potential uses of `Enumerable#minmax`."
    },
    "Style/MinMaxComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of `max` or `min` instead of comparison for greater or less.\n\nIt can be used if you want to present limit or threshold in Ruby 2.7+. That it is slow though. So autocorrection will apply generic `max` or `min`:\n\na.clamp(b..) # Same as `[a, b].max` a.clamp(..b) # Same as `[a, b].min`"
    },
    "Style/MissingElse": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "if",
            "case",
            "both"
          ],
          "description": "Default: both"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: if, case, both"
        }
      },
      "description": "Checks for `if` expressions that do not have an `else` branch.\n\nPattern matching is allowed to have no `else` branch because unlike `if` and `case`, it raises `NoMatchingPatternError` if the pattern doesn't match and without having `else`.\n\nSupported styles are: if, case, both."
    },
    "Style/MissingRespondToMissing": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the presence of `method_missing` without also defining `respond_to_missing?`."
    },
    "Style/MixinGrouping": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "separated",
            "grouped"
          ],
          "description": "Default: separated"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: separated, grouped"
        }
      },
      "description": "Checks for grouping of mixins in `class` and `module` bodies. By default it enforces mixins to be placed in separate declarations, but it can be configured to enforce grouping them in one declaration."
    },
    "Style/MixinUsage": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks that `include`, `extend` and `prepend` statements appear inside classes and modules, not at the top level, so as to not affect the behavior of `Object`."
    },
    "Style/ModuleFunction": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "module_function",
            "extend_self",
            "forbidden"
          ],
          "description": "Default: module_function"
        },
        "Autocorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: module_function, extend_self, forbidden"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for use of `extend self` or `module_function` in a module.\n\nSupported styles are: `module_function` (default), `extend_self` and `forbidden`.\n\nA couple of things to keep in mind:\n\n - forbidden style prohibits the usage of both styles\n\n - in default mode (module_function), the cop wonâ€™t be activated when the module contains any private methods"
    },
    "Style/MultilineBlockChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for chaining of a block after another block that spans multiple lines."
    },
    "Style/MultilineIfModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of if/unless modifiers with multiple-lines bodies."
    },
    "Style/MultilineIfThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of the `then` keyword in multi-line if statements."
    },
    "Style/MultilineInPatternThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks uses of the `then` keyword in multi-line `in` statement."
    },
    "Style/MultilineMemoization": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "keyword",
            "braces"
          ],
          "description": "Default: keyword"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: keyword, braces"
        }
      },
      "description": "Checks expressions wrapping styles for multiline memoization."
    },
    "Style/MultilineMethodSignature": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for method signatures that span multiple lines."
    },
    "Style/MultilineTernaryOperator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for multi-line ternary op expressions.\n\n`return if ... else ... end` is syntax error. If `return` is used before multiline ternary operator expression, it will be autocorrected to single-line ternary operator. The same is true for `break`, `next`, and method call."
    },
    "Style/MultilineWhenThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks uses of the `then` keyword in multi-line when statements."
    },
    "Style/MultipleComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowMethodComparison": {
          "type": "boolean",
          "description": "Default: true"
        },
        "ComparisonsThreshold": {
          "type": "integer",
          "description": "Default: 2"
        }
      },
      "description": "Checks against comparing a variable with multiple items, where `Array#include?`, `Set#include?` or a `case` could be used instead to avoid code repetition. It accepts comparisons of multiple method calls to avoid unnecessary method calls by default. It can be configured by `AllowMethodComparison` option."
    },
    "Style/MutableConstant": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "literals",
            "strict"
          ],
          "description": "Default: literals"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: literals, strict"
        }
      },
      "description": "Checks whether some constant value isn't a mutable literal (e.g. array or hash).\n\nStrict mode can be used to freeze all constants, rather than just literals. Strict mode is considered an experimental feature. It has not been updated with an exhaustive list of all methods that will produce frozen objects so there is a decent chance of getting some false positives. Luckily, there is no harm in freezing an already frozen object.\n\nFrom Ruby 3.0, this cop honours the magic comment 'shareable_constant_value'. When this magic comment is set to any acceptable value other than none, it will suppress the offenses raised by this cop. It enforces frozen state.\n\nRegexp and Range literals are frozen objects since Ruby 3.0.\n\nFrom Ruby 3.0, interpolated strings are not frozen when `# frozen-string-literal: true` is used, so this cop enforces explicit freezing for such strings.\n\nFrom Ruby 3.0, this cop allows explicit freezing of constants when the `shareable_constant_value` directive is used."
    },
    "Style/NegatedIf": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "both",
            "prefix",
            "postfix"
          ],
          "description": "Default: both"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: both, prefix, postfix"
        }
      },
      "description": "Checks for uses of if with a negated condition. Only ifs without else are considered. There are three different styles:\n\n - both\n\n - prefix\n\n - postfix"
    },
    "Style/NegatedIfElseCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of `if-else` and ternary operators with a negated condition which can be simplified by inverting condition and swapping branches."
    },
    "Style/NegatedUnless": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "both",
            "prefix",
            "postfix"
          ],
          "description": "Default: both"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: both, prefix, postfix"
        }
      },
      "description": "Checks for uses of unless with a negated condition. Only unless without else are considered. There are three different styles:\n\n - both\n\n - prefix\n\n - postfix"
    },
    "Style/NegatedWhile": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of while with a negated condition."
    },
    "Style/NestedFileDirname": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for nested `File.dirname`. It replaces nested `File.dirname` with the level argument introduced in Ruby 3.1."
    },
    "Style/NestedModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for nested use of if, unless, while and until in their modifier form."
    },
    "Style/NestedParenthesizedCalls": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: be, be_a, be_an, be_between, be_falsey, be_kind_of, be_instance_of, be_truthy, be_within, eq, eql, end_with, include, match, raise_error, respond_to, start_with"
        }
      },
      "description": "Checks for unparenthesized method calls in the argument list of a parenthesized method call. `be`, `be_a`, `be_an`, `be_between`, `be_falsey`, `be_kind_of`, `be_instance_of`, `be_truthy`, `be_within`, `eq`, `eql`, `end_with`, `include`, `match`, `raise_error`, `respond_to`, and `start_with` methods are allowed by default. These are customizable with `AllowedMethods` option."
    },
    "Style/NestedTernaryOperator": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for nested ternary op expressions."
    },
    "Style/Next": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "skip_modifier_ifs",
            "always"
          ],
          "description": "Default: skip_modifier_ifs"
        },
        "MinBodyLength": {
          "type": "integer",
          "description": "Default: 3"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: skip_modifier_ifs, always"
        }
      },
      "description": "Use `next` to skip iteration instead of a condition at the end."
    },
    "Style/NilComparison": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "predicate",
            "comparison"
          ],
          "description": "Default: predicate"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: predicate, comparison"
        }
      },
      "description": "Checks for comparison of something with nil using `==` and `nil?`.\n\nSupported styles are: predicate, comparison."
    },
    "Style/NilLambda": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for lambdas and procs that always return nil, which can be replaced with an empty lambda or proc instead."
    },
    "Style/NonNilCheck": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "IncludeSemanticChanges": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for non-nil checks, which are usually redundant.\n\nWith `IncludeSemanticChanges` set to `false` by default, this cop does not report offenses for `!x.nil?` and does no changes that might change behavior. Also `IncludeSemanticChanges` set to `false` with `EnforcedStyle: comparison` of `Style/NilComparison` cop, this cop does not report offenses for `x != nil` and does no changes to `!x.nil?` style.\n\nWith `IncludeSemanticChanges` set to `true`, this cop reports offenses for `!x.nil?` and autocorrects that and `x != nil` to solely `x`, which is *usually* OK, but might change behavior."
    },
    "Style/Not": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of the keyword `not` instead of `!`."
    },
    "Style/NumberedParameters": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "allow_single_line",
            "disallow"
          ],
          "description": "Default: allow_single_line"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: allow_single_line, disallow"
        }
      },
      "description": "Checks for numbered parameters.\n\nIt can either restrict the use of numbered parameters to single-lined blocks, or disallow completely numbered parameters."
    },
    "Style/NumberedParametersLimit": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Max": {
          "type": "integer",
          "description": "Default: 1"
        }
      },
      "description": "Detects use of an excessive amount of numbered parameters in a single block. Having too many numbered parameters can make code too cryptic and hard to read.\n\nThe cop defaults to registering an offense if there is more than 1 numbered parameter but this maximum can be configured by setting `Max`."
    },
    "Style/NumericLiteralPrefix": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedOctalStyle": {
          "enum": [
            "zero_with_o",
            "zero_only"
          ],
          "description": "Default: zero_with_o"
        },
        "SupportedOctalStyles": {
          "type": "array",
          "description": "Default: zero_with_o, zero_only"
        }
      },
      "description": "Checks for octal, hex, binary, and decimal literals using uppercase prefixes and corrects them to lowercase prefix or no prefix (in case of decimals)."
    },
    "Style/NumericLiterals": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "MinDigits": {
          "type": "integer",
          "description": "Default: 5"
        },
        "Strict": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowedNumbers": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for big numeric literals without `_` between groups of digits in them.\n\nAdditional allowed patterns can be added by adding regexps to the `AllowedPatterns` configuration. All regexps are treated as anchored even if the patterns do not contain anchors (so `\\d{4}_\\d{4}` will allow `1234_5678` but not `1234_5678_9012`).\n\nEven if `AllowedPatterns` are given, autocorrection will only correct to the standard pattern of an `_` every 3 digits."
    },
    "Style/NumericPredicate": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles",
          "description": "Default: spec/**/*"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "predicate",
            "comparison"
          ],
          "description": "Default: predicate"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: predicate, comparison"
        }
      },
      "description": "Checks for usage of comparison operators (`==`, `>`, `<`) to test numbers as zero, positive, or negative. These can be replaced by their respective predicate methods. This cop can also be configured to do the reverse.\n\nThis cop can be customized allowed methods with `AllowedMethods`. By default, there are no methods to allowed.\n\nThis cop disregards `#nonzero?` as its value is truthy or falsey, but not `true` and `false`, and thus not always interchangeable with `!= 0`.\n\nThis cop allows comparisons to global variables, since they are often populated with objects which can be compared with integers, but are not themselves `Integer` polymorphic."
    },
    "Style/ObjectThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "then",
            "yield_self"
          ],
          "description": "Default: then"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: then, yield_self"
        }
      },
      "description": "Enforces the use of consistent method names `Object#yield_self` or `Object#then`."
    },
    "Style/OneLineConditional": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AlwaysCorrectToMultiline": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for uses of if/then/else/end constructs on a single line. AlwaysCorrectToMultiline config option can be set to true to auto-convert all offenses to multi-line constructs. When AlwaysCorrectToMultiline is false (default case) the autocorrect will first try converting them to ternary operators."
    },
    "Style/OpenStructUse": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Reference": {
          "type": "array",
          "description": "Default: https://docs.ruby-lang.org/en/3.0.0/OpenStruct.html#class-OpenStruct-label-Caveats"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Flags uses of OpenStruct, as it is now officially discouraged to be used for performance, version compatibility, and potential security issues."
    },
    "Style/OperatorMethodCall": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant dot before operator method call. The target operator methods are `|`, `^`, `&`, `<=>`, `==`, `===`, `=~`, `>`, `>=`, `<`, `<=`, `<<`, `>>`, `+`, `-`, `*`, `/`, `%`, `**`, `~`, `!`, `!=`, and `!~`."
    },
    "Style/OptionHash": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SuspiciousParamNames": {
          "type": "array",
          "description": "Default: options, opts, args, params, parameters"
        },
        "Allowlist": {
          "type": "array",
          "description": "Default: []"
        }
      },
      "description": "Checks for options hashes and discourages them if the current Ruby version supports keyword arguments."
    },
    "Style/OptionalArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for optional arguments to methods that do not come at the end of the argument list."
    },
    "Style/OptionalBooleanParameter": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: respond_to_missing?"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where keyword arguments can be used instead of boolean arguments when defining methods. `respond_to_missing?` method is allowed by default. These are customizable with `AllowedMethods` option."
    },
    "Style/OrAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for potential usage of the `||=` operator."
    },
    "Style/ParallelAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for simple usages of parallel assignment. This will only complain when the number of variables being assigned matched the number of assigning variables."
    },
    "Style/ParenthesesAroundCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowSafeAssignment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowInMultilineConditions": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the presence of superfluous parentheses around the condition of if/unless/while/until.\n\n`AllowSafeAssignment` option for safe assignment. By safe assignment we mean putting parentheses around an assignment to indicate \"I know I'm using an assignment as a condition. It's not a mistake.\""
    },
    "Style/PercentLiteralDelimiters": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "PreferredDelimiters": {
          "description": "Default: {\"default\"â‡’\"()\", \"%i\"â‡’\"[]\", \"%I\"â‡’\"[]\", \"%r\"â‡’\"{}\", \"%w\"â‡’\"[]\", \"%W\"â‡’\"[]\"}"
        }
      },
      "description": "Enforces the consistent usage of `%`-literal delimiters.\n\nSpecify the 'default' key to set all preferred delimiters at once. You can continue to specify individual preferred delimiters to override the default."
    },
    "Style/PercentQLiterals": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "lower_case_q",
            "upper_case_q"
          ],
          "description": "Default: lower_case_q"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: lower_case_q, upper_case_q"
        }
      },
      "description": "Checks for usage of the %Q() syntax when %q() would do."
    },
    "Style/PerlBackrefs": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Looks for uses of Perl-style regexp match backreferences and their English versions like $1, $2, $&, &+, $MATCH, $PREMATCH, etc."
    },
    "Style/PreferredHashMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "short",
            "verbose"
          ],
          "description": "Default: short"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: short, verbose"
        }
      },
      "description": "Checks for uses of methods `Hash#has_key?` and `Hash#has_value?`, and suggests using `Hash#key?` and `Hash#value?` instead.\n\nIt is configurable to enforce the verbose method names, by using the `EnforcedStyle: verbose` configuration."
    },
    "Style/Proc": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of Proc.new where Kernel#proc would be more appropriate."
    },
    "Style/QuotedSymbols": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "same_as_string_literals",
            "single_quotes",
            "double_quotes"
          ],
          "description": "Default: same_as_string_literals"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: same_as_string_literals, single_quotes, double_quotes"
        }
      },
      "description": "Checks if the quotes used for quoted symbols match the configured defaults. By default uses the same configuration as `Style/StringLiterals`; if that cop is not enabled, the default `EnforcedStyle` is `single_quotes`.\n\nString interpolation is always kept in double quotes.\n\nNote: `Lint/SymbolConversion` can be used in parallel to ensure that symbols are not quoted that don't need to be. This cop is for configuring the quoting style to use for symbols that require quotes."
    },
    "Style/RaiseArgs": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "compact",
            "exploded"
          ],
          "description": "Default: exploded"
        },
        "AllowedCompactTypes": {
          "type": "array",
          "description": "Default: []"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: compact, exploded"
        }
      },
      "description": "Checks the args passed to `fail` and `raise`. For exploded style (default), it recommends passing the exception class and message to `raise`, rather than construct an instance of the error. It will still allow passing just a message, or the construction of an error with more than one argument.\n\nThe exploded style works identically, but with the addition that it will also suggest constructing error objects when the exception is passed multiple arguments.\n\nThe exploded style has an `AllowedCompactTypes` configuration option that takes an Array of exception name Strings."
    },
    "Style/RandomWithOffset": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for the use of randomly generated numbers, added/subtracted with integer literals, as well as those with Integer#succ and Integer#pred methods. Prefer using ranges instead, as it clearly states the intentions."
    },
    "Style/RedundantArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Methods": {
          "description": "Default: {\"join\"â‡’\"\", \"sum\"â‡’0, \"exit\"â‡’true, \"exit!\"â‡’false, \"split\"â‡’\" \", \"chomp\"â‡’\"\\n\", \"chomp!\"â‡’\"\\n\"}"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for a redundant argument passed to certain methods.\n\nThis cop is limited to methods with single parameter.\n\nMethod names and their redundant arguments can be configured like this:\n\nMethods:   join: ''   sum: 0   split: ' '   chomp: \"\\n\"   chomp!: \"\\n\"   foo: 2"
    },
    "Style/RedundantArrayConstructor": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for the instantiation of array using redundant `Array` constructor. Autocorrect replaces to array literal which is the simplest and fastest."
    },
    "Style/RedundantAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant assignment before returning."
    },
    "Style/RedundantBegin": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant `begin` blocks.\n\nCurrently it checks for code like this:"
    },
    "Style/RedundantCapitalW": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for usage of the %W() syntax when %w() would do."
    },
    "Style/RedundantCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for unnecessary conditional expressions."
    },
    "Style/RedundantConditional": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant returning of true/false in conditionals."
    },
    "Style/RedundantConstantBase": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Avoid redundant `::` prefix on constant.\n\nHow Ruby searches constant is a bit complicated, and it can often be difficult to understand from the code whether the `::` is intended or not. Where `Module.nesting` is empty, there is no need to prepend `::`, so it would be nice to consistently avoid such meaningless `::` prefix to avoid confusion.\n\nThis cop is disabled if `Lint/ConstantResolution` cop is enabled to prevent conflicting rules. Because it respects user configurations that want to enable `Lint/ConstantResolution` cop which is disabled by default."
    },
    "Style/RedundantCurrentDirectoryInPath": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses a redundant current directory in path."
    },
    "Style/RedundantDoubleSplatHashBraces": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant uses of double splat hash braces."
    },
    "Style/RedundantEach": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for redundant `each`."
    },
    "Style/RedundantException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for RuntimeError as the argument of raise/fail.\n\nIt checks for code like this:"
    },
    "Style/RedundantFetchBlock": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeForConstants": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/JuanitoFatas/fast-ruby#hashfetch-with-argument-vs-hashfetch--block-code"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies places where `fetch(key) { value }` can be replaced by `fetch(key, value)`.\n\nIn such cases `fetch(key, value)` method is faster than `fetch(key) { value }`.\n\nThe block string `'value'` in `hash.fetch(:key) { 'value' }` is detected when frozen string literal magic comment is enabled (i.e. `# frozen_string_literal: true`), but not when disabled."
    },
    "Style/RedundantFileExtensionInRequire": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for the presence of superfluous `.rb` extension in the filename provided to `require` and `require_relative`.\n\nNote: If the extension is omitted, Ruby tries adding '.rb', '.so',       and so on to the name until found. If the file named cannot be found,       a `LoadError` will be raised.       There is an edge case where `foo.so` file is loaded instead of a `LoadError`       if `foo.so` file exists when `require 'foo.rb'` will be changed to `require 'foo'`,       but that seems harmless."
    },
    "Style/RedundantFilterChain": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Identifies usages of `any?`, `empty?` or `none?` predicate methods chained to `select`/`filter`/`find_all` and change them to use predicate method instead."
    },
    "Style/RedundantFreeze": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Check for uses of `Object#freeze` on immutable objects.\n\nRegexp and Range literals are frozen objects since Ruby 3.0.\n\nFrom Ruby 3.0, this cop allows explicit freezing of interpolated string literals when `# frozen-string-literal: true` is used."
    },
    "Style/RedundantHeredocDelimiterQuotes": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant heredoc delimiter quotes."
    },
    "Style/RedundantInitialize": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for `initialize` methods that are redundant.\n\nAn initializer is redundant if it does not do anything, or if it only calls `super` with the same arguments given to it. If the initializer takes an argument that accepts multiple values (`restarg`, `kwrestarg`, etc.) it will not register an offense, because it allows the initializer to take a different number of arguments as its superclass potentially does.\n\nIf an initializer argument has a default value, RuboCop assumes it to *not* be redundant.\n\nEmpty initializers are registered as offenses, but it is possible to purposely create an empty `initialize` method to override a superclass's initializer."
    },
    "Style/RedundantInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for strings that are just an interpolated expression."
    },
    "Style/RedundantLineContinuation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Check for redundant line continuation.\n\nThis cop marks a line continuation as redundant if removing the backslash does not result in a syntax error. However, a backslash at the end of a comment or for string concatenation is not redundant and is not considered an offense."
    },
    "Style/RedundantParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant parentheses."
    },
    "Style/RedundantPercentQ": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for usage of the %q/%Q syntax when '' or \"\" would do."
    },
    "Style/RedundantRegexpArgument": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Identifies places where argument can be replaced from a deterministic regexp to a string."
    },
    "Style/RedundantRegexpCharacterClass": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for unnecessary single-element Regexp character classes."
    },
    "Style/RedundantRegexpConstructor": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for the instantiation of regexp using redundant `Regexp.new` or `Regexp.compile`. Autocorrect replaces to regexp literal which is the simplest and fastest."
    },
    "Style/RedundantRegexpEscape": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant escapes inside Regexp literals."
    },
    "Style/RedundantReturn": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowMultipleReturnValues": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for redundant `return` expressions."
    },
    "Style/RedundantSelf": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant uses of `self`.\n\nThe usage of `self` is only needed when:\n\n - Sending a message to same object with zero arguments in presence of a method name clash with an argument or a local variable.\n\n - Calling an attribute writer to prevent a local variable assignment.\n\nNote, with using explicit self you can only send messages with public or protected scope, you cannot send private messages this way.\n\nNote we allow uses of `self` with operators because it would be awkward otherwise."
    },
    "Style/RedundantSelfAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where redundant assignments are made for in place modification methods."
    },
    "Style/RedundantSelfAssignmentBranch": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for places where conditional branch makes redundant self-assignment.\n\nIt only detects local variable because it may replace state of instance variable, class variable, and global variable that have state across methods with `nil`."
    },
    "Style/RedundantSort": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Identifies instances of sorting and then taking only the first or last element. The same behavior can be accomplished without a relatively expensive sort by using `Enumerable#min` instead of sorting and taking the first element and `Enumerable#max` instead of sorting and taking the last element. Similarly, `Enumerable#min_by` and `Enumerable#max_by` can replace `Enumerable#sort_by` calls after which only the first or last element is used."
    },
    "Style/RedundantSortBy": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Identifies places where `sort_by { ... }` can be replaced by `sort`."
    },
    "Style/RedundantStringEscape": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for redundant escapes in string literals."
    },
    "Style/RegexpLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "slashes",
            "percent_r",
            "mixed"
          ],
          "description": "Default: slashes"
        },
        "AllowInnerSlashes": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: slashes, percent_r, mixed"
        }
      },
      "description": "Enforces using `//` or `%r` around regular expressions.\n\nThe following `%r` cases using a regexp starts with a blank or `=` as a method argument allowed to prevent syntax errors.\n\ndo_something %r{ regexp} # `do_something / regexp/` is an invalid syntax. do_something %r{=regexp} # `do_something /=regexp/` is an invalid syntax."
    },
    "Style/RequireOrder": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Sort `require` and `require_relative` in alphabetical order."
    },
    "Style/RescueModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of `rescue` in its modifier form is added for following reasons:\n\n - The syntax of modifier form rescue can be misleading because it might lead us to believe that rescue handles the given exception but it actually rescue all exceptions to return the given rescue block. In this case, value returned by handle_error or SomeException.\n\n - Modifier form rescue would rescue all the exceptions. It would silently skip all exception or errors and handle the error. Example: If NoMethodError is raised, modifier form rescue would handle the exception."
    },
    "Style/RescueStandardError": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "implicit",
            "explicit"
          ],
          "description": "Default: explicit"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: implicit, explicit"
        }
      },
      "description": "Checks for rescuing `StandardError`. There are two supported styles `implicit` and `explicit`. This cop will not register an offense if any error other than `StandardError` is specified."
    },
    "Style/ReturnNil": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "return",
            "return_nil"
          ],
          "description": "Default: return"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: return, return_nil"
        }
      },
      "description": "Enforces consistency between `return nil` and `return`.\n\nThis cop is disabled by default. Because there seems to be a perceived semantic difference between `return` and `return nil`. The former can be seen as just halting evaluation, while the latter might be used when the return value is of specific concern.\n\nSupported styles are `return` and `return_nil`."
    },
    "Style/ReturnNilInPredicateMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks if `return` or `return nil` is used in predicate method definitions."
    },
    "Style/SafeNavigation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "ConvertCodeThatCanStartToReturnNil": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: present?, blank?, presence, try, try!"
        },
        "MaxChainLength": {
          "type": "integer",
          "description": "Default: 2"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Transforms usages of a method call safeguarded by a non `nil` check for the variable whose method is being called to safe navigation (`&.`). If there is a method chain, all of the methods in the chain need to be checked for safety, and all of the methods will need to be changed to use safe navigation.\n\nThe default for `ConvertCodeThatCanStartToReturnNil` is `false`. When configured to `true`, this will check for code in the format `!foo.nil? && foo.bar`. As it is written, the return of this code is limited to `false` and whatever the return of the method is. If this is converted to safe navigation, `foo&.bar` can start returning `nil` as well as what the method returns.\n\nThe default for `MaxChainLength` is `2` We have limited the cop to not register an offense for method chains that exceed this option is set."
    },
    "Style/Sample": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://github.com/JuanitoFatas/fast-ruby#arrayshufflefirst-vs-arraysample-code"
        }
      },
      "description": "Identifies usages of `shuffle.first`, `shuffle.last`, and `shuffle[]` and change them to use `sample` instead."
    },
    "Style/SelectByRegexp": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Looks for places where an subset of an Enumerable (array, range, set, etc.; see note below) is calculated based on a `Regexp` match, and suggests `grep` or `grep_v` instead.\n\nHashes do not behave as you may expect with `grep`, which means that `hash.grep` is not equivalent to `hash.select`. Although RuboCop is limited by static analysis, this cop attempts to avoid registering an offense when the receiver is a hash (hash literal, `Hash.new`, `Hash#[]`, or `to_h`/`to_hash`).\n\n`grep` and `grep_v` were optimized when used without a block in Ruby 3.0, but may be slower in previous versions. See https://bugs.ruby-lang.org/issues/17030"
    },
    "Style/SelfAssignment": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Enforces the use the shorthand for self-assignment."
    },
    "Style/Semicolon": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowAsExpressionSeparator": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for multiple expressions placed on the same line. It also checks for lines terminated with a semicolon.\n\nThis cop has `AllowAsExpressionSeparator` configuration option. It allows `;` to separate several expressions on the same line."
    },
    "Style/Send": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Checks for the use of the send method."
    },
    "Style/SignalException": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "only_raise",
            "only_fail",
            "semantic"
          ],
          "description": "Default: only_raise"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: only_raise, only_fail, semantic"
        }
      },
      "description": "Checks for uses of `fail` and `raise`."
    },
    "Style/SingleArgumentDig": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Sometimes using dig method ends up with just a single argument. In such cases, dig should be replaced with []."
    },
    "Style/SingleLineBlockParams": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "Methods": {
          "type": "array",
          "description": "Default: {\"reduce\"â‡’[\"acc\", \"elem\"]}, {\"inject\"â‡’[\"acc\", \"elem\"]}"
        }
      },
      "description": "Checks whether the block parameters of a single-line method accepting a block match the names specified via configuration.\n\nFor instance one can configure `reduce`(`inject`) to use |a, e| as parameters.\n\nConfiguration option: Methods Should be set to use this cop. Array of hashes, where each key is the method name and value - array of argument names."
    },
    "Style/SingleLineMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowIfMethodIsEmpty": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for single-line method definitions that contain a body. It will accept single-line methods with no body.\n\nEndless methods added in Ruby 3.0 are also accepted by this cop.\n\nIf `Style/EndlessMethod` is enabled with `EnforcedStyle: allow_single_line` or `allow_always`, single-line methods will be autocorrected to endless methods if there is only one statement in the body."
    },
    "Style/SlicingWithRange": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks that arrays are sliced with endless ranges instead of `ary[start..-1]` on Ruby 2.6+."
    },
    "Style/SoleNestedConditional": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowModifier": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "If the branch of a conditional consists solely of a conditional node, its conditions can be combined with the conditions of the outer branch. This helps to keep the nesting level from getting too deep."
    },
    "Style/SpecialGlobalVars": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "RequireEnglish": {
          "type": "boolean",
          "description": "Default: true"
        },
        "EnforcedStyle": {
          "enum": [
            "use_perl_names",
            "use_english_names",
            "use_builtin_english_names"
          ],
          "description": "Default: use_english_names"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: use_perl_names, use_english_names, use_builtin_english_names"
        }
      },
      "description": "Looks for uses of Perl-style global variables. Correcting to global variables in the 'English' library will add a require statement to the top of the file if enabled by RequireEnglish config.\n\nLike `use_perl_names` but allows builtin global vars.\n\n  # good\n  puts $LOAD_PATH\n  puts $LOADED_FEATURES\n  puts $PROGRAM_NAME\n  puts ARGV\n  puts $:\n  puts $\"\n  puts $0\n  puts $!\n  puts $@\n  puts $;\n  puts $,\n  puts $/\n  puts $\\\n  puts $.\n  puts $_\n  puts $>\n  puts $<\n  puts $$\n  puts $?\n  puts $~\n  puts $=\n  puts $*"
    },
    "Style/StabbyLambdaParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "require_parentheses",
            "require_no_parentheses"
          ],
          "description": "Default: require_parentheses"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: require_parentheses, require_no_parentheses"
        }
      },
      "description": "Check for parentheses around stabby lambda arguments. There are two different styles. Defaults to `require_parentheses`."
    },
    "Style/StaticClass": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where classes with only class methods can be replaced with a module. Classes should be used only when it makes sense to create instances out of them."
    },
    "Style/StderrPuts": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Identifies places where `$stderr.puts` can be replaced by `warn`. The latter has the advantage of easily being disabled by, the `-W0` interpreter flag or setting `$VERBOSE` to `nil`."
    },
    "Style/StringChars": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for uses of `String#split` with empty string or regexp literal argument."
    },
    "Style/StringConcatenation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Mode": {
          "type": "string",
          "description": "Default: aggressive"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for places where string concatenation can be replaced with string interpolation.\n\nThe cop can autocorrect simple cases but will skip autocorrecting more complex cases where the resulting code would be harder to read. In those cases, it might be useful to extract statements to local variables or methods which you can then interpolate in a string.\n\nWhen concatenation between two strings is broken over multiple lines, this cop does not register an offense; instead, `Style/LineEndConcatenation` will pick up the offense if enabled.\n\nTwo modes are supported: 1. `aggressive` style checks and corrects all occurrences of `+` where either the left or right side of `+` is a string literal. 2. `conservative` style on the other hand, checks and corrects only if left side (receiver of `+` method call) is a string literal. This is useful when the receiver is some expression that returns string like `Pathname` instead of a string literal."
    },
    "Style/StringHashKeys": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for the use of strings as keys in hashes. The use of symbols is preferred instead."
    },
    "Style/StringLiterals": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "single_quotes",
            "double_quotes"
          ],
          "description": "Default: single_quotes"
        },
        "ConsistentQuotesInMultiline": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: single_quotes, double_quotes"
        }
      },
      "description": "Checks if uses of quotes match the configured preference."
    },
    "Style/StringLiteralsInInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "single_quotes",
            "double_quotes"
          ],
          "description": "Default: single_quotes"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: single_quotes, double_quotes"
        }
      },
      "description": "Checks that quotes inside string, symbol, and regexp interpolations match the configured preference."
    },
    "Style/StringMethods": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "PreferredMethods": {
          "description": "Default: {\"intern\"â‡’\"to_sym\"}"
        }
      },
      "description": "Enforces the use of consistent method names from the String class."
    },
    "Style/Strip": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Identifies places where `lstrip.rstrip` can be replaced by `strip`."
    },
    "Style/StructInheritance": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for inheritance from Struct.new."
    },
    "Style/SwapValues": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "SafeAutoCorrect": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces the use of shorthand-style swapping of 2 variables."
    },
    "Style/SymbolArray": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "percent",
            "brackets"
          ],
          "description": "Default: percent"
        },
        "MinSize": {
          "type": "integer",
          "description": "Default: 2"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: percent, brackets"
        }
      },
      "description": "Checks for array literals made up of symbols that are not using the %i() syntax.\n\nAlternatively, it checks for symbol arrays using the %i() syntax on projects which do not want to use that syntax, perhaps because they support a version of Ruby lower than 2.0.\n\nConfiguration option: MinSize If set, arrays with fewer elements than this value will not trigger the cop. For example, a `MinSize` of `3` will not enforce a style on an array of 2 or fewer elements."
    },
    "Style/SymbolLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks symbol literal syntax."
    },
    "Style/SymbolProc": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AllowMethodsWithArguments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: define_method"
        },
        "AllowedPatterns": {
          "type": "array",
          "description": "Default: []"
        },
        "AllowComments": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Use symbols as procs when possible.\n\nIf you prefer a style that allows block for method with arguments, please set `true` to `AllowMethodsWithArguments`. `define_method?` methods are allowed by default. These are customizable with `AllowedMethods` option."
    },
    "Style/TernaryParentheses": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "require_parentheses",
            "require_no_parentheses",
            "require_parentheses_when_complex"
          ],
          "description": "Default: require_no_parentheses"
        },
        "AllowSafeAssignment": {
          "type": "boolean",
          "description": "Default: true"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: require_parentheses, require_no_parentheses, require_parentheses_when_complex"
        }
      },
      "description": "Checks for the presence of parentheses around ternary conditions. It is configurable to enforce inclusion or omission of parentheses using `EnforcedStyle`. Omission is only enforced when removing the parentheses won't cause a different behavior.\n\n`AllowSafeAssignment` option for safe assignment. By safe assignment we mean putting parentheses around an assignment to indicate \"I know I'm using an assignment as a condition. It's not a mistake.\""
    },
    "Style/TopLevelMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        }
      },
      "description": "Newcomers to ruby applications may write top-level methods, when ideally they should be organized in appropriate classes or modules. This cop looks for definitions of top-level methods and warns about them.\n\nHowever for ruby scripts it is perfectly fine to use top-level methods. Hence this cop is disabled by default."
    },
    "Style/TrailingBodyOnClass": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for trailing code after the class definition."
    },
    "Style/TrailingBodyOnMethodDefinition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for trailing code after the method definition.\n\nIt always accepts endless method definitions that are basically on the same line."
    },
    "Style/TrailingBodyOnModule": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for trailing code after the module definition."
    },
    "Style/TrailingCommaInArguments": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyleForMultiline": {
          "enum": [
            "comma",
            "consistent_comma",
            "no_comma"
          ],
          "description": "Default: no_comma"
        },
        "SupportedStylesForMultiline": {
          "type": "array",
          "description": "Default: comma, consistent_comma, no_comma"
        }
      },
      "description": "Checks for trailing comma in argument lists. The supported styles are:\n\n - consistent_comma: Requires a comma after the last argument, for all parenthesized method calls with arguments.\n\n - comma: Requires a comma after the last argument, but only for parenthesized method calls where each argument is on its own line.\n\n - no_comma: Requires that there is no comma after the last argument."
    },
    "Style/TrailingCommaInArrayLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyleForMultiline": {
          "enum": [
            "comma",
            "consistent_comma",
            "no_comma"
          ],
          "description": "Default: no_comma"
        },
        "SupportedStylesForMultiline": {
          "type": "array",
          "description": "Default: comma, consistent_comma, no_comma"
        }
      },
      "description": "Checks for trailing comma in array literals. The configuration options are:\n\n - consistent_comma: Requires a comma after the last item of all non-empty, multiline array literals.\n\n - comma: Requires a comma after last item in an array, but only when each item is on its own line.\n\n - no_comma: Does not require a comma after the last item in an array"
    },
    "Style/TrailingCommaInBlockArgs": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks whether trailing commas in block arguments are required. Blocks with only one argument and a trailing comma require that comma to be present. Blocks with more than one argument never require a trailing comma."
    },
    "Style/TrailingCommaInHashLiteral": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyleForMultiline": {
          "enum": [
            "comma",
            "consistent_comma",
            "no_comma"
          ],
          "description": "Default: no_comma"
        },
        "SupportedStylesForMultiline": {
          "type": "array",
          "description": "Default: comma, consistent_comma, no_comma"
        }
      },
      "description": "Checks for trailing comma in hash literals. The configuration options are:\n\n - consistent_comma: Requires a comma after the last item of all non-empty, multiline hash literals.\n\n - comma: Requires a comma after the last item in a hash, but only when each item is on its own line.\n\n - no_comma: Does not require a comma after the last item in a hash"
    },
    "Style/TrailingMethodEndStatement": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for trailing code after the method definition."
    },
    "Style/TrailingUnderscoreVariable": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "AllowNamedUnderscoreVariables": {
          "type": "boolean",
          "description": "Default: true"
        }
      },
      "description": "Checks for extra underscores in variable assignment."
    },
    "Style/TrivialAccessors": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "ExactNameMatch": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowPredicates": {
          "type": "boolean",
          "description": "Default: true"
        },
        "AllowDSLWriters": {
          "type": "boolean",
          "description": "Default: true"
        },
        "IgnoreClassMethods": {
          "type": "boolean",
          "description": "Default: false"
        },
        "AllowedMethods": {
          "type": "array",
          "description": "Default: to_ary, to_a, to_c, to_enum, to_h, to_hash, to_i, to_int, to_io, to_open, to_path, to_proc, to_r, to_regexp, to_str, to_s, to_sym"
        }
      },
      "description": "Looks for trivial reader/writer methods, that could have been created with the attr_* family of functions automatically. `to_ary`, `to_a`, `to_c`, `to_enum`, `to_h`, `to_hash`, `to_i`, `to_int`, `to_io`, `to_open`, `to_path`, `to_proc`, `to_r`, `to_regexp`, `to_str`, `to_s`, and `to_sym` methods are allowed by default. These are customizable with `AllowedMethods` option."
    },
    "Style/UnlessElse": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Looks for `unless` expressions with `else` clauses."
    },
    "Style/UnlessLogicalOperators": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "forbid_mixed_logical_operators",
            "forbid_logical_operators"
          ],
          "description": "Default: forbid_mixed_logical_operators"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: forbid_mixed_logical_operators, forbid_logical_operators"
        }
      },
      "description": "Checks for the use of logical operators in an `unless` condition. It discourages such code, as the condition becomes more difficult to read and understand.\n\nThis cop supports two styles:\n\n - forbid_mixed_logical_operators (default)\n\n - forbid_logical_operators\n\n`forbid_mixed_logical_operators` style forbids the use of more than one type of logical operators. This makes the `unless` condition easier to read because either all conditions need to be met or any condition need to be met in order for the expression to be truthy or falsey.\n\n`forbid_logical_operators` style forbids any use of logical operator. This makes it even more easy to read the `unless` condition as there is only one condition in the expression."
    },
    "Style/UnpackFirst": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for accessing the first element of `String#unpack` which can be replaced with the shorter method `unpack1`."
    },
    "Style/VariableInterpolation": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for variable interpolation (like \"#@ivar\")."
    },
    "Style/WhenThen": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for `when;` uses in `case` expressions."
    },
    "Style/WhileUntilDo": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for uses of `do` in multi-line `while/until` statements."
    },
    "Style/WhileUntilModifier": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for while and until statements that would fit on one line if written as a modifier while/until. The maximum line length is configured in the `Layout/LineLength` cop."
    },
    "Style/WordArray": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        },
        "EnforcedStyle": {
          "enum": [
            "percent",
            "brackets"
          ],
          "description": "Default: percent"
        },
        "MinSize": {
          "type": "integer",
          "description": "Default: 2"
        },
        "WordRegex": {
          "description": "Default: (?-mix:\\A(?:\\p{Word}|\\p{Word}-\\p{Word}|\\n|\\t)+\\z)"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: percent, brackets"
        }
      },
      "description": "Checks for array literals made up of word-like strings, that are not using the %w() syntax.\n\nAlternatively, it can check for uses of the %w() syntax, in projects which do not want to include that syntax.\n\nWhen using the `percent` style, %w() arrays containing a space will be registered as offenses.\n\nConfiguration option: MinSize If set, arrays with fewer elements than this value will not trigger the cop. For example, a `MinSize` of `3` will not enforce a style on an array of 2 or fewer elements."
    },
    "Style/YAMLFileRead": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: pending"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "AutoCorrect": {
          "type": "boolean"
        }
      },
      "description": "Checks for the use of `YAML.load`, `YAML.safe_load`, and `YAML.parse` with `File.read` argument.\n\n`YAML.safe_load_file` was introduced in Ruby 3.0."
    },
    "Style/YodaCondition": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "EnforcedStyle": {
          "enum": [
            "forbid_for_all_comparison_operators",
            "forbid_for_equality_operators_only",
            "require_for_all_comparison_operators",
            "require_for_equality_operators_only"
          ],
          "description": "Default: forbid_for_all_comparison_operators"
        },
        "Reference": {
          "type": "string",
          "description": "Default: https://en.wikipedia.org/wiki/Yoda_conditions"
        },
        "SupportedStyles": {
          "type": "array",
          "description": "Default: forbid_for_all_comparison_operators, forbid_for_equality_operators_only, require_for_all_comparison_operators, require_for_equality_operators_only"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Enforces or forbids Yoda conditions, i.e. comparison operations where the order of expression is reversed. eg. `5 == x`"
    },
    "Style/YodaExpression": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: false"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        },
        "SupportedOperators": {
          "type": "array",
          "description": "Default: *, +, &, |, ^"
        }
      },
      "description": "Forbids Yoda expressions, i.e. binary operations (using `*`, `+`, `&`, `|`, and `^` operators) where the order of expression is reversed, eg. `1 + x`. This cop complements `Style/YodaCondition` cop, which has a similar purpose.\n\nThis cop is disabled by default to respect user intentions such as:\n\nconfig.server_port = 9000 + ENV[\"TEST_ENV_NUMBER\"].to_i"
    },
    "Style/ZeroLengthPredicate": {
      "type": "object",
      "additionalProperties": true,
      "propertyNames": {
        "$ref": "#/definitions/attributeName"
      },
      "properties": {
        "Enabled": {
          "type": "boolean",
          "description": "Default: true"
        },
        "Exclude": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Include": {
          "$ref": "#/definitions/listOfFiles"
        },
        "Severity": {
          "$ref": "#/definitions/severity"
        },
        "Details": {
          "type": "string"
        },
        "StyleGuideBaseURL": {
          "type": "string"
        },
        "StyleGuide": {
          "type": "string"
        },
        "Safe": {
          "type": "boolean",
          "description": "Default: false"
        }
      },
      "description": "Checks for numeric comparisons that can be replaced by a predicate method, such as `receiver.length == 0`, `receiver.length > 0`, and `receiver.length != 0`, `receiver.length < 1` and `receiver.size == 0` that can be replaced by `receiver.empty?` and `!receiver.empty?`.\n\n`File`, `Tempfile`, and `StringIO` do not have `empty?` so allow `size == 0` and `size.zero?`."
    }
  }
}
